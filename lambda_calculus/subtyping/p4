                                                                            SUBTIPADO

1)

a) Dar una derivaciÃ³n que pruebe que {x : Nat, y : Nat, z : Nat} <: {y : Nat}. Â¿Es Ãºnica?

                                           
{y} âŠ† {x, y, z}    Nat<:Nat
________________________________________(S-Rcd)
{x : Nat, y : Nat, z : Nat} <: {y : Nat}



Otra forma

Pruebo que vale {x : Nat, y : Nat, z : Nat} <: {y : Nat,x : Nat, z : Nat}

{x : Nat, y : Nat, z : Nat} es permutaciÃ³n de {y : Nat, x : Nat, z : Nat}
_________________________________________________________________________(S-RcdPerm)
{x : Nat, y : Nat, z : Nat} <: {y : Nat, x : Nat, z : Nat}

Y ahora veo que vale {y : Nat,x : Nat, z : Nat} <: {y : Nat}


_______________________________________(S-RcdWidth)
{y : Nat, x : Nat, z : Nat} <: {y : Nat}

Luego, por transitividad vale que {x : Nat, y : Nat, z : Nat} <: {y : Nat}


b) Dar al menos dos derivaciones de {x : Nat, y : Nat} <: {}


_______________________(S-RcdWidth)
{x : Nat, y : Nat} <: {}

                                          _______________________(S-RcdWidth)
{x : Nat, y : Nat} <: {y : Nat, x : Nat}  {y : Nat, x : Nat} <: {} 
_____________________________________________________________________________(S-RcdPerm) => PREGUNTA: esto es re trucho â˜¹ï¸
{x : Nat, y : Nat} <: {}



2) Asumiendo que tenemos los tipos bÃ¡sicos, Top, funciones y registros (sin referencias ni otras extensiones)...

a) Â¿CuÃ¡les son los tipos que tienen infinitos subtipos?

Cualquier tipo registro tiene un subtipo que resulta de agregarle un campo extra. Por lo tanto, cualquier tipo registro tiene infinitos subtipos.
Cualquier tipo es subtipo del tipo Top. En particular, el tipo registro es subtipo de Top. Por lo tanto, Top tambiÃ©n tiene infinitos subtipos.
Las funciones que tienen codominios de tipo Top o tipo registro, tambiÃ©n tienen infinitos subtipos (ya que el codominio puede subtiparse infinitamente).


b) Â¿CuÃ¡les son los tipos que tienen infinitos supertipos?

Las funciones que tienen dominos de tipo Top o tipo registro, tienen infinitos supertipos (ya que el dominio puede subtiparse infinitamente).


3)

a) Â¿Es verdad que âˆƒS âˆ€T T <: S? Verdadero. Top es supertipo de todos los tipos.

b) Â¿Es verdad que âˆƒS âˆ€T S <: T ? Falso. No hay un subtipo en comÃºn para todos los tipos.

DemostraciÃ³n.

Supongo que vale la proposiciÃ³n. Luego tendrÃ­a que darse que exista S tal que S <: Bool y, por ejemplo, S <: {}. Pero si S <: Bool => S = Bool y Bool no subtipa {}. ABSURDO

c) Â¿Es verdad que âˆƒS1, S2 âˆ€T1, T2 S1 â†’ S2 <: T1 â†’ T2? Falso.

T1 <: S1  S2 <: T2            ________________________________________________________________________________________________________________________________________________________________
__________________(S-Func) =>|IDEA: T1 = Bool y T2 = Bool => S1 estÃ¡ en {Bool, Nat, Int, Float} y S2 = Bool. Por otro lado, T1 = Bool y T2 = {} => S1 estÃ¡ en {Bool, Nat, Int, Float} y S2 es |
S1 â†’ S2 <: T1 â†’ T2           |                                                                                                                      algÃºn registro que extiende {}            |
                             |                               No se puede encontrar un subtipo en comÃºn entre estos dos tipos.                                                                 |
                             |________________________________________________________________________________________________________________________________________________________________|

Si se diera esto, entones tendrÃ­a que existir S1 para todo T1 tal que T1 <: S1. Esto vale tomando S1 como Top.
Por otro lado, tendrÃ­a que darse que exista S2 para todo T2 tal que S2 <: T2. Esto es falso por b).

Luego no vale la proposiciÃ³n.

d) Â¿Es verdad que âˆƒS1, S2 âˆ€T1, T2 T1 â†’ T2 <: S1 â†’ S2? 

S1 <: T1  T2 <: S2
__________________(S-Func)
T1 â†’ T2 <: S1 â†’ S2

Para que se cumpla esto, tiene que existir S1 para todo T1 tal que S1 <: T1, esto es falso por b).

Luego no vale la proposiciÃ³n.



4) Decidir si cada uno de los siguientes enunciados es verdadero o falso. Si es verdadero demostrarlo y si es falso dar un contraejemplo.

a) T <: S si y sÃ³lo si existe un A tal que S â†’ T <: A â†’ A.

DemostraciÃ³n.

=>)

Si T <: S entonces tomando A = T quiero ver que S â†’ T <: T â†’ T.

Vale por hipÃ³tesis      Vale
__________________      _______
T <: S                  T <: T
_______________________________________(S-Func)
S â†’ T  <:  A â†’ A


<=)

Si existe A tal que S â†’ T <: A â†’ A, entonces vale lo siguiente:

A <: S  T <: A
________________(S-Func)
S â†’ T  <:  A â†’ A

Luego por transitividad de <:, T <: S.



b) {x: S, y : T} siempre tiene menos supertipos que S â†’ T.

S' <: S  T <: T'
__________________(S-Func) => IDEA: Quiero que S' y T' sean Ãºnicos.
S â†’ T <: S' â†’ T'

Tomando S = Bool y T = Float vale que si S' <: S => S' = Bool y si T <: T' => T' = Float. Entonces el Ãºnico supertipo de Bool â†’ Float es Bool â†’ Float.

Por otro lado, {x : Bool, y : Float} tiene como supertipos {x : Bool} y {} (entre otros). 

Luego es falsa la proposiciÃ³n.



c) {x: S, y : T} nunca tiene menos supertipos que S â†’ T.

S' <: S  T <: T'
__________________(S-Func) => IDEA: Quiero que S' o T' sean infinitos.
S â†’ T <: S' â†’ T'

Tomando S = Top y T = Float vale que si S' <: S => S' es cualquier tipo y si T <: T' => T' = Float. Entonces Top â†’ Float tiene infinitos supertipos.

Por otro lado {x : Top, y : Float}

{li | i âˆˆ 1..n} âŠ† {x : Top, y : Float}      kj = li â‡’ Ïƒj<:Ï„i donde Ïƒj es el tipo de kj en {x : Top, y : Float} 
______________________________________________________________________________________________________________(S-Rcd)
{x : Top, y : Float} <: {li : Ï„i | i âˆˆ 1..n}

Entonces {li : Ï„i | i âˆˆ 1..n} = {y : T', x : S'}|{x : S', y : T'}|{x : S'}|{y : T'}|{}. Entonces resta por ver quÃ© tipos pueden ser S' y T'.

Si Top <: S' => S' = Top.

Si Float <: T' => T' = Float.

Luego, el conjunto de supertipos de {x : Top, y : Float} es {{y : Float, x : Top}, {x : Top, y : Float}, {x : Top}, {y : Float}, {}}.

Por lo tanto es falsa la proposiciÃ³n.



5) Exhibir tipos R, S y T tales que R <: S y R <: T pero no exista una relaciÃ³n de subtipado entre S y T.

R = {x : {}, y : Bool}

S = {x : {}}

T = {y : Bool}

R <: T y R <: S por S-Rcd pero no hay regla que permita establecer una relaciÃ³n de subtipado entre S y T (ya sea S <: T o T <: S)



6) Supongamos que sÃ³lo podemos construir tipos con Bool, Nat y funciones (sin registros). Demostrar que para todo tipo S construido de esa manera, la cantidad de subtipos y de supertipos de S es finita.

DemostraciÃ³n.

S no es tipo funciÃ³n.


Entonces S estÃ¡ en {Bool, Nat}. Si S = Bool y se tiene S' tal que S <: S', entonces S' estÃ¡ en {Bool, Nat, Int, Float}. Si S = Nat, entonces S' estÃ¡ en {Nat, Int, Float}. De forma anÃ¡loga, los subtipos estÃ¡n en {Bool} y {Bool, Nat} respectivamente.


S tipo funciÃ³n.
 

Por inducciÃ³n en la complejidad del tÃ©rmino de tipo (un tÃ©rmino M es mÃ¡s complejo que uno N si hay mÃ¡s apariciones de â†’ en M que en en N). 

Los casos base son los del paso anterior. 

Dados M y N tales que vale la hipÃ³tesis inductiva, quiero ver que tambiÃ©n se cumple para M â†’ N.

Supertipos.

M' <: M  N <: N'
__________________(S-Func)
M â†’ N <: M' â†’ N'

La cantidad de supertipos M' â†’ N' estÃ¡ dada por #_supertipos(N)*#_subtipos(M) y esto es finito por hipÃ³tesis inductiva. 

Subtipos.

M <: M'  N' <: N
__________________(S-Func)
M' â†’ N' <: M â†’ N

De forma anÃ¡loga, la cantidad de subtipos M' â†’ N' estÃ¡ dada por #_supertipos(M)*#_subtipos(N) y esto es finito por hipÃ³tesis inductiva. 




                                                                            SUBTIPADO EN EL CONTEXTO DE TIPADO

7) Probar que los siguientes tÃ©rminos tipan si se tienen en cuenta las reglas de subtipado vistas en clase.


a) Î»x: Bool.(Î»y : Nat.succ(y)) x

y : Nat âˆˆ Î“ âˆª {x : Bool} âˆª {y : Nat}
____________________________________(T-Var)
Î“ âˆª {x : Bool} âˆª {y : Nat} > y : Nat                                   x : Bool âˆˆ Î“ âˆª {x : Bool}
___________________________________________(T-Succ) => Ïƒ = Nat         _________________________(T-Var) ___________(S-BoolNat)
Î“ âˆª {x : Bool} âˆª {y : Nat} > succ(y) : Ïƒ                               Î“ âˆª {x : Bool} > x : Bool        Bool <: Nat
_______________________________________________________________(T-Abs) _______________________________________________________(S-Sub)
Î“ âˆª {x : Bool} > Î»y : Nat.succ(y) : Nat â†’ Ïƒ                            Î“ âˆª {x : Bool} > x : Nat
_____________________________________________________________________________________________________________________________________(T-App)
Î“ âˆª {x : Bool} > (Î»y : Nat.succ(y)) x : Ïƒ
_____________________________________________________________________________________________________________________________________________(T-Abs)
Î“ > Î»x: Bool.(Î»y : Nat.succ(y)) x : Bool â†’ Ïƒ


b) (Î»r : {l1 : Bool, l2 : Float}.if r.l1 then r.l2 else 5,5) {l1 = true, l2 = âˆ’8, l3 = 9,0}


                                                                      No hay una regla para aplicar
Î“' > r : C  l1 : Bool âˆˆ C          Î“' > r : C  l2 : Float âˆˆ C         pero deberÃ­a funcionar (*)
_________________________(T-Proj)  __________________________(T-Proj) ________________(???)
Î“' > r.l1 : Bool                   Î“' > r.l2 : Float                  Î“' > 5,5 : Float
___________________________________________________________________________________________(T-If)           
Î“' > if r.l1 then r.l2 else 5,5 : Float                                                                     
_________________________________________________________________________________________________(T-Abs)    
Î“ > Î»r : {l1 : Bool, l2 : Float}.if r.l1 then r.l2 else 5,5 : {l1 : Bool, l2 : Float} â†’ Float               (1)
______________________________________________________________________________________________________________________________________________________________________________________(T-App)
Î“ > (Î»r : {l1 : Bool, l2 : Float}.if r.l1 then r.l2 else 5,5) {l1 = true, l2 = âˆ’8, l3 = 9,0} : Float

Î“' = Î“ âˆª {r : {l1 : Bool, l2 : Float}}
C = {l1 : Bool, l2 : Float}

    
(1)
                       Idem (*)
                       ____________(???) ____________(T-IntFloat)
                       Î“ > -8 : Int      Int <: Float                Idem (*)
______________(T-True) ______________________________________(T-Sub) _______________(???)
Î“ > true : Bool        Î“ > -8 : Float                                Î“ > 9,0 : Float
__________________________________________________________________________________________(T-Rcd)  ______________________________________________________________(S-RcdWidth)
Î“ > {l1 = true, l2 = âˆ’8, l3 = 9,0} : {l1 : Bool, l2 : Float, l3 : Float}                           {l1 : Bool, l2 : Float, l3 : Float} <: {l1 : Bool, l2 : Float}
______________________________________________________________________________________________________________________________________________________________________________(T-Sub)
Î“ > {l1 = true, l2 = âˆ’8, l3 = 9,0} : {l1 : Bool, l2 : Float}



8) Mostrar que el tÃ©rmino xx no es tipable en cÃ¡lculo-Î» clÃ¡sico, pero sÃ­ es tipable al considerar las reglas de subtipado segÃºn lo visto. Exhibir contexto y tipo para este tÃ©rmino.


Ya se mostrÃ³ que no tipa en otra prÃ¡ctica.

                                                          x : Ï„ â†’ Ïƒ âˆˆ Î“
                                                          _____________(T-Var) __________(S-Top) => Ï„ = Top => Top â†’ Ïƒ <: Top vale por definiciÃ³n de Top. PREGUNTA: esto es horrible de nuevo â˜¹ï¸
x : Ï„ â†’ Ïƒ âˆˆ Î“  => Âµ = Ï„ â†’ Ïƒ                               Î“ > x : Ï„ â†’ Ïƒ        Ï„ â†’ Ïƒ <: Ï„ 
______________(T-Var)                                     ____________________________________(T-Sub)
Î“ > x : Ï„ â†’ Ïƒ                                             Î“ > x : Ï„   
______________________________________________________________________________________________________________________________________(T-App)
Î“ > xx : Ïƒ

Î“ = {x : Âµ}

Entonces Î“ = {x : Top â†’ Ïƒ} > xx : Ïƒ



9) En este ejercicio trabajaremos con los tipos Bool <: Nat <: Int <: Float, funciones y registros.

Puede asumirse que Float tiene la operaciÃ³n +, que Int tiene ademÃ¡s las operaciones pred y suc, y que Bool cuenta tambiÃ©n con la operaciÃ³n if, con las reglas de tipado habituales:

                                                Î“ > M : Int
                                                ________________(T-Suc)
                                                Î“ > suc(M) : Int


                                                Î“ > M : Int
                                                __________________(T-Pred)
                                                Î“ > pred(M) : Int


                                                Î“ > M : Float  Î“ > N : Float
                                                ____________________________(T-+)
                                                Î“ > M + N : Float


                                                Î“ > M : Bool  Î“ > N : Ïƒ  Î“ > O : Ïƒ
                                                ___________________________________(T-If)
                                                Î“ > if M then N else O : Ïƒ


a) Suponer que la regla de subtipado para funciones fuera contravariante en el argumento y en el resultado, es decir:

S <: T  U <: V
______________(S-Arrow')
T â†’ V <: S â†’ U

Mostrar que esto no serÃ­a una buena idea:

- Dar una expresiÃ³n M del cÃ¡lculo lambda.
- Explicar brevemente por quÃ© no tiene sentido evaluar M.
- Demostrar que, sin embargo, M tiene tipo.


M = PENSAR





REGLA CORRECTA

S1 <: T1  T2 <: S2
__________________(S-Func)
T1 â†’ T2 <: S1 â†’ S2



b) Suponer ahora que la regla de subtipado para funciones fuera covariante en el argumento y en el resultado es decir:

S <: T  U <: V
_______________(S-Arrow'')
S â†’ U <: T â†’ V



M = (Î»f : Int â†’ Bool. f 2) (Î»x : Bool. if x then true else false)


No tiene sentido reducir esto ya que le estoy pasando, a la primera lambda, una funciÃ³n con un tipo de dominio mÃ¡s restrictivo que el que espera que tenga. AsÃ­, es posible que queden fuera valores que deberÃ­an ser vÃ¡lidos. Por ejemplo, no tiene sentido evaluar f 2 cuando f : Bool â†’ Bool. Sin embargo tipa:


                                        ______________________________(T-Zero)  __________(S-NatInt)
                                        Î“ âˆª {f : Int â†’ Bool} > 0 : Nat          Nat <: Int
                                        ________________________________________________________________(T-Sub)
=> Ï„ â†’ Ïƒ = Int â†’ Bool                   Î“ âˆª {f : Int â†’ Bool} > 0 : Int
                                        _______________________________________________________________________(T-Suc)
f : Ï„ â†’ Ïƒ âˆˆ Î“ âˆª {f : Int â†’ Bool}        Î“ âˆª {f : Int â†’ Bool} > 1 : Int
________________________________(T-Var) ______________________________________________________________________________(T-Suc)   
Î“ âˆª {f : Int â†’ Bool} > f : Ï„ â†’ Ïƒ        Î“ âˆª {f : Int â†’ Bool} > 2 : Int          
_____________________________________________________________________________________________________________________________(T-App)   
Î“ âˆª {f : Int â†’ Bool} > f 2 : Ïƒ                                                 
____________________________________________________________________________________________________________________________________(T-Abs) 
Î“ > Î»f : Int â†’ Bool. f 2 : (Int â†’ Bool) â†’ Ïƒ                                                                                                                              (1)
________________________________________________________________________________________________________________________________________________________________________________________(T-App)
Î“ > (Î»f : Int â†’ Bool. f 2) (Î»x : Bool. if x then true else false) : Ïƒ





(1)

x : Bool âˆˆ Î“ âˆª {x : Bool}
_________________________(T-Var)  ____________________________(T-True)  _____________________________(T-False)
Î“ âˆª {x : Bool} > x : Bool         Î“ âˆª {x : Bool} > True : Bool          Î“ âˆª {x : Bool} > False : Bool
_______________________________________________________________________________________________________________(T-Abs) _________________________(S-Arrow'')
Î“ > Î»x : Bool. if x then true else false : Bool â†’ Bool                                                                 Bool â†’ Bool <: Int â†’ Bool
____________________________________________________________________________________________________________________________________________________________________(T-Sub)
Î“ > Î»x : Bool. if x then true else false : Int â†’ Bool



10)

a) Suponer que el operador Ref es covariante. Escribir un programa (en un lenguaje a elecciÃ³n) que arroje error/excepciÃ³n a causa de esto.


b) Hacer lo mismo pero suponiendo que el operador Ref es contravariante.


Ejemplos, en cÃ¡lculo lambda, para ambos casos en la teÃ³rica.



11) Supongamos que agregamos al lenguaje el tipo Comp_Ïƒ, para representar comparadores de tÃ©rminos de tipo Ïƒ. Los comparadores tienen la operaciÃ³n mejorSegÃºn, que indica si el primer tÃ©rmino es mejor que el segundo.

                                            Î“ > M : Comp_Ïƒ   Î“ > N : Ïƒ   Î“ > O : Ïƒ
                                            _______________________________________(T-Comp)
                                            Î“ > mejorSegÃºn(M, N, O) : Bool

a) El siguente tÃ©rmino: Î»c : Comp_{x:Int}.mejorSegÃºn(c, {x = 1, y = 2}, {x = 0})

Â¿DeberÃ­a ser tipable, en tÃ©rminos del principio de sustitutividad? Â¿Lo es? En caso afirmativo, dar una derivaciÃ³n que lo pruebe. Pueden asumirse como axiomas:

                                            Î“ > {x = 1, y = 2} : {x : Int, y : Int}         Î“ > {x = 0} : {x : Int}
                               

                                                AXIOMA                                                                                      AXIOMA
                               _______________________________________(T-Rcd) ______________________________(T-RcdWidth)          ________________________(T-Sub)
c : Comp_{x : Int} âˆˆ Î“'        Î“' > {x = 1, y = 2} : {x : Int, y : Int}       {x : Int, y : Int} <: {x : Int}                     Î“' > 0 : Int
_______________________(T-Var) ___________________________________________________________________________________________(T-Sub) _______________________________(T-Rcd)  
Î“' > c : Comp_{x : Int}        Î“' > {x = 1, y = 2} : {x : Int}                                                                    Î“' > {x = 0} : {x : Int}    
________________________________________________________________________________________________________________________________________________________________________(T-Comp) => Ï„ = Bool
Î“' > mejorSegÃºn{c. {x = 1, y = 2}, {x = 0}} : Ï„
________________________________________________________________________________________________________________________________________________________________________________________(T-Abs)
Î“ > Î»c : Comp_{x:Int}.mejorSegÃºn(c, {x = 1, y = 2}, {x = 0}) : Comp_{x:Int} â†’ Ï„

Î“' = Î“ âˆª {c : Comp_{x:Int}}

PREGUNTA: es correcto el paso de aplicaciÃ³n de T-Comp? resolvÃ­ el tipo {x : Int} como el menos restrictivo entre todos los candidatos ğŸ¤”ï¸

b) Dar la o las reglas de subtipado para comparadores.


Ïƒ <: Ï„ 
________________(S-Comp) => Si quiero poder reemplazar Comp_Ïƒ por Comp_Ï„ en cualquier contexto sin problemas, entonces Comp_Ï„ debe ser, por lo menos, tan general como Comp_Ïƒ. Por ejemplo, si 
Comp_Ï„ <: Comp_Ïƒ            Ïƒ = Nat, quisiera que Ï„ sea supertipo de Nat para poder manejar todas las comparaciones entre Nats y tal vez alguna entre Ints.


c) El siguiente tÃ©rmino: Î»c : Comp_Float.(Î»x: Comp_Nat.mejorSegÃºn(x, 3, 4)) c

Â¿DeberÃ­a ser tipable, en tÃ©rminos del principio de sustitutividad? Â¿SegÃºn las reglas dadas, lo es? En caso afirmativo, dar una derivaciÃ³n que lo pruebe. Pueden asumirse como axiomas:

                                           Î“ > 3 : Nat         Î“ > 4 : Nat


x : Comp_Nat âˆˆ Î“''          AXIOMA          AXIOMA
___________________(T-Var) _____________   _____________                            
Î“'' > x : Comp_Nat         Î“'' > 3 : Nat   Î“'' > 4 : Nat                               c : Comp_Float âˆˆ Î“'         Nat <: Float
_________________________________________________________(T-Comp) => Ïƒ = Bool          ___________________(T-Var)  ______________________(S-Comp)    
 > mejorSegÃºn(x, 3, 4) : Ïƒ                                                             Î“' > c : Comp_Float         Comp_Float <: Comp_Nat 
______________________________________________________________________________(T-Abs)  _______________________________________________________________(T-Sub)
Î“' > Î»x: Comp_Nat.mejorSegÃºn(x, 3, 4) : Comp_Nat â†’ Ïƒ                                   Î“' > c : Comp_Nat
___________________________________________________________________________________________________________________________________________________________________(T-App)
Î“' > (Î»x: Comp_Nat.mejorSegÃºn(x, 3, 4)) c : Ïƒ
__________________________________________________________________________________________________________________________________________________________________________(T-Abs)
Î“ > Î»c : Comp_Float.(Î»x: Comp_Nat.mejorSegÃºn(x, 3, 4)) c : Comp_Float â†’ Ïƒ


Î“' = Î“ âˆª {c : Comp_Float}
Î“'' = Î“' âˆª {x : Comp_Nat}



12)



13)



14) Considerar un tipo Animal, mÃ¡s una jerarquÃ­a de subtipos que (por brevedad) limitaremos aquÃ­ a Vaca y LeÃ³n, mÃ¡s un tipo paramÃ©trico AlimentoPara(Ïƒ) que identifica valores que pueden ser ingeridos por todos los de tipo Ïƒ.

AdemÃ¡s de las T-Sub y S-Trans usuales se han definido estas reglas de tipado y de subtipado:

                                                                                                                                            Î“ > M : Ïƒ   Î“ > N : AlimentoPara(Ïƒ)
_____________________(T-Clara)         ______________(S-LeÃ³n)       ______________(S-Vaca)      _________________________(S-VacaLeÃ³n)       ___________________________________(T-Comer) 
Î“ > Clarabelle : Vaca                  LeÃ³n <: Animal               Vaca <: Animal              Vaca <: AlimentoPara(LeÃ³n)                  Î“ > comer(M, N) : Ïƒ



a) Suponer que alguien nos propone incorporar la siguiente regla de subtipado:


Ïƒ <: Ïƒ'
__________________________________(S-Alim)
AlimentoPara(Ïƒ) <: AlimentoPara(Ïƒ')


_____________________________________________________________________
                                                                     |
                  LeÃ³n <: Animal                                     |                  
                                                                     |
                  Vaca <: Animal                                     |
                                                                     |
                  Vaca <: AlimentoPara(LeÃ³n)                         |
                                                                     |
    AlimentoPara(LeÃ³n) <: AlimentoPara(Animal)                       |
                                                                     |
    AlimentoPara(Vaca) <: AlimentoPara(Animal)                       |
_____________________________________________________________________|


Argumentar que no es buena idea mostrando que, con esta regla, Clarabelle se come a sÃ­ misma. Es decir, dar una derivaciÃ³n que pruebe que el tÃ©rmino comer(Clarabelle, Clarabelle) resultarÃ­a tipable.

Sugerencia: notar que el cÃ¡lculo pretende capturar cierta nociÃ³n de cadenas alimentarias (quiÃ©n come a quiÃ©n). Antes de hacer cuentas, pensar cÃ³mo lo intenta, y por quÃ©. Imaginar la misma idea en contextos con fauna mÃ¡s diversa tambiÃ©n puede ser Ãºtil para comprender las ventajas y detectar los problemas del enfoque.
                             

                                                       _____________________(T-Clara) _________________________(S-VacaLeÃ³n)         ______________(S-LeÃ³n)
                                                       Î“ > Clarabelle : Vaca          Vaca <: AlimentoPara(LeÃ³n)                    LeÃ³n <: Animal
_____________________(T-Clara) ______________(S-Vaca)  _____________________________________________________________________(T-Sub) _________________________________________(S-Alim)
Î“ > Clarabelle : Vaca          Vaca <: Animal          Î“ > Clarabelle : AlimentoPara(LeÃ³n)                                          AlimentoPara(LeÃ³n) <: AlimentoPara(Animal)        
______________________________________________(T-Sub)  ______________________________________________________________________________________________________________________________(T-Sub)   
Î“ > Clarabelle : Animal                                Î“ > Clarabelle : AlimentoPara(Animal)  
______________________________________________________________________________________________________________________________________________________________________________________(T-Comer)
Î“ > comer(Clarabelle, Clarabelle) : Animal


b)  Informalmente, el conjunto de valores de tipo AlimentoPara(Ïƒ) es el caracterizado por la propiedad:

                            y âˆˆ AlimentoPara(Ïƒ) â‡” âˆ€x âˆˆ Ïƒ . x puede comer y

Sin embargo, el problema que ilustra el punto a) es que la regla permite que las vacas coman alimento para leones. Proponer una nueva versiÃ³n de S-Alim. Explicar brevemente por quÃ© tiene mÃ¡s sentido que la original.

Idea:

Si AlimentoPara(Ïƒ) es subtipo de AlimentoPara(Ïƒ') e y âˆˆ AlimentoPara(Ïƒ), entonces cualquier integrante del tipo Ïƒ' debe poder comerse a y. 

En tÃ©rminos de Ïƒ' y Ïƒ, esto requiere que Ïƒ'<:Ïƒ. Por ejemplo:


Si AlimentoPara(Felino) es subtipo de AlimentoPara(Tigre) e y âˆˆ AlimentoPar(Felino), entonces cualquier integrante del tipo Tigre debe poder comerse a y.

El enunciado que aparece arriba, tiene mucho sentido ya que cualquier tigre puede comer algo que sea comida de cualquier felino. En cierto modo, el alimento para Felino debe incluir todos los alimentos de los distintos subtipos de felinos que hay. Es decir, el alimento para Felino estÃ¡ constituido por la uniÃ³n de los alimentos para todos sus subtipos. Por ello tiene sentido que AlimentoPara(Felino) subtipe de AlimentoPara(Ïƒ), donde Ïƒ <: Felino.

Esto es similar a lo que ocurre con los registros donde {} es el mÃ¡s general y a medida que se agregan campos se obtienen subtipos. AcÃ¡ AlimentoPara(Tigre) es uno de los mÃ¡s generales (junto con todas las hojas) y a medida que se avanza hacia la raÃ­z del Ã¡rbol se agregan alimentos.


Tigre----
         |
          ---- Felinos ---------
         |                      |
LeÃ³n-----                       |
                                 ------- Animal
Vaca -----                      |
          |                     |
           ----Rumiante --------
          |
Ciervo ---


Ïƒ' <: Ïƒ
__________________________________(S-Alim)
AlimentoPara(Ïƒ) <: AlimentoPara(Ïƒ')



16)













