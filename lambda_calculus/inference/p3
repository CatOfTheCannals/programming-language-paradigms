                                                                        INFERENCIA

1) Determinar qué expresiones son sintácticamente válidas y, para las que sean, indicar a qué gramática pertenecen.

PREGUNTA: los términos formados por variables de tipo son válidos en el cálculo lambda sin anotaciones o funcionan como un recurso para el algoritmo? Por ejemplo, λx: s1 → s2.if 0 then True else 0 succ(True)

______________________________________________________Válidas______________________________________________________
                
                Generadas por M                    Generadas por σ             Generadas por M'

                λx: Bool.succ(x)                       s → σ                     λx.isZero(x)
                
                                                         s
                                                        
                                                    s → (Bool → t)





_____________________________________________________Inválidas_____________________________________________________
                
                                                    Erase(f y) => Erase es parte de las expresiones asociadas al algoritmo de inferencia pero no forma parte de las del
                                                                                                                                                               lenguaje
                                           Erase(λf : Bool → s.λy : Bool.f y)
        


2) Determinar el resultado de aplicar la sustitución S a las siguientes expresiones.


i. S = {t ← Nat}    S({x : t → Bool}) => x : Nat → Bool

ii. S = {t1 ← t2 → t3, t ← Bool}    S({x : t → Bool}) > S(λx: t1 → Bool.x): S(Nat → t2) => {x : Bool → Bool} > (λx: t2 → t3 → Bool.x) : Nat → t2



3) Determinar el resultado de aplicar el MGU ("most general unifier") sobre las ecuaciones planteadas a continuación.

En caso de tener éxito, mostrar la sustitución resultante. 


i. MGU {t1 → t2 ≐ Nat → Bool} =1=> {t1 ≐ Nat, t2 ≐ Bool} =4=> {t2 ≐ Bool} | {Nat/t1} =4=> {} | {Bool/t2} ◦ {Nat/t1}  

ii. MGU {t1 → t2 ≐ t3} =3=> {t3 ≐ t1 → t2} =4=> {} | {t1 → t2/t3}

iii. MGU {t1 → t2 ≐ t2} =6=> ERROR

iv. MGU {(t2 → t1) → Bool ≐ t2 → t3} =1=> {t2 → t1 ≐ t2, t1 ≐ t3} =6=> ERROR 

v. MGU {t2 → t1 → Bool ≐ t2 → t3} =1=> {t2 ≐ t2, t1 → Bool ≐ t3} =2=> {t1 → Bool ≐ t3} =3=> {t3 ≐ t1 → Bool} =4=> {} | {t1 → Bool/t3}
                                                     
                                                 PREGUNTA: van paréntesis o no en el reemplazo de t1 por t2 → t3? @paréntesis
vi. MGU {t1 → Bool ≐ Nat → Bool, t1 ≐ t2 → t3} =4=> {(t2 → t3) → Bool ≐ Nat → Bool} | {t2 → t3/t1} =1=> {t2 → t3 ≐ Nat, Bool ≐ Bool} | {t2 → t3/t1} =5=> ERROR

vii. MGU {t1 → Bool ≐ Nat → Bool, t2 ≐ t1 → t1} =4=> {t1 → Bool ≐ Nat → Bool} | {t1 → t1/t2} =1=> {t1 ≐ Nat, Bool ≐ Bool} | {t1 → t1/t2} =4=> {Bool ≐ Bool} | {Nat/t1} ◦ {t1 → t1/t2} =2=> {} | {Nat/t1} ◦ {t1 → t1/t2} PREGUNTA: es correcto dejarlo así o debería aplicar Nat/t1 sobre todo lo que ya tenía? 

                                                         PREGUNTA: misma duda de paréntesis pero con el reemplazo de t3 por t2 → t1 @paréntesis
                                                                   si pongo paréntesis, queda t1 ≐ t2 → t1 y t2 ≐ t4 => ERROR
                                                                   si no pongo, tengo t1 ≐ t2 y t2 ≐ t1 → t4 =4=> t1 ≐ t1 → t4 =6=> ERROR
viii. MGU {t1 → t2 ≐ t3 → t4, t3 ≐ t2 → t1} =4=> {t1 → t2 ≐ (t2 → t1) → t4} | {t2 → t1/t3} =1=> {t1 ≐ t2 → t1, t2 ≐ t4} | {t2 → t1/t3} =6=> ERROR



4) Unir con flechas los tipos que unifican entre sí (entre una fila y la otra). Para cada par unificable, exhibir el mgu ("most general unifier").

t → u                   Nat                     u → Bool                    a → b → c


t                       Nat → Bool              (Nat → u) → Bool            Nat → u → Bool



t → u       con Nat → Bool          => {Nat/t, Bool/u}
            con u → Bool            => PREGUNTA: no se puede porque no hay un orden particular de la aplicación? Por ejemplo, {u/t, Bool/u} => Se puede: RECORDAR CORRER EL ALGORITMO SOBRE LA UNIFICACIÓN
            con (Nat → u) → Bool    => Idem anterior pero con {Nat → u/t, Bool/u}
            con Nat → u → Bool      => Idem anterior 
            con a → b → c           => PREGUNTA: Cuál es el mgu: {a/t, b → c/u} o {a → b/t, c/u}?

u → Bool    con Nat → Bool          => {Nat/u}

a → b → c   con (Nat → u) → Bool    => PREGUNTA: para lograr unificarlos debería ser posible agregar paréntesis, solamente se agregan cuando se reemplaza una variable 
                                                 por un tipo función? @paréntesis
   
t           con Nat                 => {Nat/t}
            con Nat → Bool          => {Nat → Bool/t}
            con u → Bool            => {u → Bool/t}
            con (Nat → u) → Bool    => {(Nat → u) → Bool/t}
            con a → b → c           => {a → b → c/t}
            con Nat → u → Bool      => {Nat → u → Bool/t}



5) Decidir, utilizando el método del árbol, cuáles de las siguientes expresiones son tipables. Mostrar qué reglas y sustituciones se aplican en cada paso y justificar por qué no son tipables aquéllas que fallan.

i. λz. if z then 0 else succ(0)

                                                                    λz. if z then 0 else succ(0) =>  ø > λz : Bool. if z then 0 else succ(0) : Bool → Nat
                                                                                 |
                                                                        if z then 0 else succ(0) => {z : Bool} > if z then 0 else succ(0) : Nat 
                                                                                 |
                                                                                 |               
                                                                                 | S = MGU {Nat ≐ Nat, t1 ≐ Bool} = {Bool/t1}
                                                                                 |
                         ________________________________________________________|________________________________________________________
                        |                                                        |                                                        |
                        z => {z : t1} > z : t1                                  0 => ø > 0 : Nat                                       succ(0) => ø > succ(0) : Nat
                                                                                                                                          |
                                                                                                                                          0 => ø > 0 : Nat



ii. λy. succ((λx.x) y)

                                                                    λy. succ((λx.x) y) => ø > λy : Nat. succ((λx.x) y) : Nat → Nat
                                                                            |
                                                                        succ((λx.x) y) => {y : Nat} > succ((λx.x) y) : Nat 
                                                                            |
                                                                            | S = MGU {t1 ≐ Nat} = {Nat/t1}
                                                                            |
                                                                         (λx.x) y => {y : t1} > (λx.x) y : t1  
                                                                            |
                                                                            | S = MGU {t1 → t1 ≐ t3 → t4} = {t1 ≐ t3, t1 ≐ t4} = {t1/t3, t1/t4}
                                    ________________________________________|________________________________________
                                   |                                                                                 |
                                  λx.x => ø > λx : t1.x : t1 → t1                                                    y => {y : t3} > y : t3
                                   |
                                   x => {x : t1} > x : t1  



iii. λx. if isZero(x) then x else (if x then x else x)


                        λx. if isZero(x) then x else (if x then x else x)
                                              |
                            if isZero(x) then x else (if x then x else x)
                                              |
                                              | S = MGU {Nat ≐ Bool, t5 ≐ Bool} => ERROR
       _______________________________________|_______________________________________
      |                                       |                                       |
   isZero(x) => {x : Nat} > isZero(x) : Bool  x => {x : t5} > x : t5        (if x then x else x) => {x : Bool} > (if x then x else x) : Bool 
      |                                                                               |
      x {x : t4} > x : t4                                                             |  S = MGU {t1 ≐ Bool, t1 ≐ t2, t2 ≐ t3, t1 ≐ t3} = {Bool/t1, Bool/t2, Bool/t3}
                                                               _______________________|_______________________       
                                                              |                       |                       |
                                                              x => {x : t1} > x : t1  x => {x : t2} > x : t2  x => {x : t3} > x : t3



iv. λx.λy. if x then y else succ(0)

                λx.λy. if x then y else succ(0) => ø > λx : Bool.λy : Nat. if x then y else succ(0) : Bool → Nat → Nat  
                            |
                   λy. if x then y else succ(0) => {x : Bool} > λy : Nat. if x then y else succ(0) : Nat → Nat 
                            |
                       if x then y else succ(0) => {x : Bool, y : Nat} > if  then y else succ(0) : Nat
                            |
                            | S = MGU {t2 ≐ Bool, t1 ≐ Nat} = {Bool/t2, Nat/t1} 
 ___________________________|___________________________
|                           |                           |
x => {x : t2} > x : t2      y => {y : y1} > y : t1   succ(0) => ø > succ(0) : Nat
                                                        |
                                                        0 => ø > 0 : Nat


Quedan para el lector (?
_________________________________________________
v. if True then (λx. 0) 0 else (λx. 0) False     |
vi. (λf. if True then f 0 else f False) (λx. 0)  |
vii. λx.λy.λz. if z then y else succ(x)          |
_________________________________________________|


viii. fix (λx. pred(x))

Para el punto viii, asumir extentido el algoritmo de inferencia con W(fix) = ∅ > fix_a : (a → a) → a donde a es una variable fresca.

                        fix (λx. pred(x)) => ø > fix (λx. pred(x)) : Nat 
                                |
                                | S = MGU {Nat → Nat ≐ t2 → t2} = {Nat ≐ t2, Nat ≐ t2} = {Nat ≐ t2} = {Nat/t2}
                                |
                             λx. pred(x) => ø > λx : Nat. pred(x) : Nat → Nat
                                |
                              pred(x) => {x : Nat} > pred(x) : Nat 
                                |
                                | S = MGU {t1 ≐ Nat} = {Nat/t1}
                                |
                                x => {x : t1} > x : t1



6) 

i. λx. λy. λz. (z x) y z

    PREGUNTA: podrían no estar los paréntesis y conservar la semántica?

                                                                      λx. λy. λz. (z x) y z
                                                                                |
                                                                        λy. λz. (z x) y z
                                                                                |
                                                                           λz. (z x) y z
                                                                                |
                                                                            (z x) y z
                                                                                |                                                   @paréntesis
                                                                                | S = MGU {t6 ≐ t2 → t4 → t5, t5 ≐ t6 → t7} = {t5 ≐ (t2 → t4 → t5) → t7} | {t2 → t4 → t5/ t6} => ERROR 
                                            ____________________________________|____________________________________
                                           |                                                                         |
                                        (z x) y => {z : t2 → t4 → t5, x : t2} > (z x) y : t5                         z => {z : t6} > z : t6
                                           |
                                           | S = MGU {t3 ≐ t4 → t5} = {t4 → t5/t3}
                       ____________________|____________________
                      |                                         |
                     z x => {z : t2 → t3, x : t2} > z x : t3    y => {y : t4} > y : t4
                      |
                      | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/ t1}
  ____________________|____________________
 |                                         |
 z => {z : t1} > z : t1                    x => {x : t2} > x : t2


Para el lector parte 2.
_________________________
ii.                      |
...                      |
vii.                     |
_________________________|



7) Indicar tipos σ y τ apropiados de modo que los términos de la forma λy : σ.λx : τ.y^n(x) resulten tipables para todo n natural. El par (σ, τ) debe ser el mismo para todos los términos. Observar si tienen todos el mismo tipo. Notación: M^0(N) = N, M^(n+1)(N) = M(M^n(N)). Sugerencia: empezar haciendo inferencia para n = 2 (es decir, calcular W(λy.λx.y(yx))) y generalizar el resultado.


                                                                            λy.λx.y(yx) => ø > λy : t3 → t3.λx : t3.y(yx) : (t3 → t3) → t3 → t3 
                                                                                |
                                                                             λx.y(yx) => {y : t3 → t3} > λx : t3.y(yx) : t3 → t3 
                                                                                |
                                                                              y(yx) => {y : t3 → t3, x : t3} > y(yx) : t3
                                                                                |
                                                                                | S = MGU {t4 ≐ t2 → t3, t4 ≐ t3 → t5} = {t2 → t3 ≐ t3 → t5} | {t2 → t3/t4} = {t2 → t3/t4, t3/t2, t3/t5}
                                                                   _____________|_____________
                                                                  |                           |
                                                                  y => {y : t4} > y : t4     yx => {y : t2 → t3, x : t2} > y x : t3
                                                                                              |
                                                                                              | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/t1}
                                                                                 _____________|_____________
                                                                                |                           |
                                                                                y => {y : t1} > y : t1      x => {x : t2} > x :t2



Dado que y toma elementos de su imagen como argumento (ya que se puede hacer y(yx)), entonces los tipos del dominio y la imágen deben coincidir (t3 → t3). Por otro lado, como x es pasado como argumento de y, debe tener el tipo que acepta y (t3). Finalmente, debido a que la lambda es una aplicación anidada de y, el tipo de salida es el de la imagen de y (t3).

En general, tomando (σ, τ) = (t3 → t3, t3) se consigue lo que se quiere.

Todos los términos tienen el mismo tipo ya que los tipos de los argumentos no cambian aunque lo haga el subtérmino de la lambda. Es decir, continúa recibiendo una función de tipo t3 → t3, una variable de tipo t3 y devuelve algo de tipo t3.

PREGUNTA: es necesaria la demostración por inducción?

Sean M : t3 → t3 y N : t3. Supongo que vale que M^k(N) : t3, con k >= 2, entonces, si R = M^k(N), por E-App vale M R : t3. Es decir, M(M^k(N)) : t3 => M^(k+1)(N) : t3.  



8) 

PREGUNTA: qué pasa si me quedan variables de tipo al terminar la aplicación del algoritmo? reemplazo por tipos genéricos? NO! DEVUEVLO ASÍ 

                                                                                λy.(x y) (λz.x2) => {x : t2 → (t5 → t4) → t7, x2 : t4} > λy : t2.(x y) (λz.x2) : t2 → t7
                                                                                        |
                                                                                   (x y) (λz.x2) => {x : t2 → (t5 → t4) → t7, y : t2, x2 : t4} > (x y) (λz.x2) : t7 
                                                                                        |
                                                                                        | S = MGU {t3 ≐ (t5 → t4) → t7} = {(t5 → t4) → t7/t3}
                                            ____________________________________________|____________________________________________
                                           |                                                                                         |
                                          x y => {x : t2 → t3, y : t2} > x y : t3                                                  λz.x2 => {x2 : t4} > λz : t5.x2 : t5 → t4
                                           |                                                                                         |   
                                           | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/t1}                                                  x2 => {x2 : t4} > x2 : t4
                           ________________|________________                                                                         
                          |                                 |                                                                        
                          x => {x : t1} > x : t1            y => {y : t2} > y : t2





{x : t2 → (t5 → t4) → t7, x2 : t4} > λy : t2.(x y) (λz.x2) : t2 → t7



9)

Tener en cuenta un nuevo tipo par definido como: σ ::= . . . | σ × σ

Con expresiones nuevas definidas como: M ::= . . . | ⟨M, M⟩ | π1(M) | π2(M)

Y las siguientes reglas de tipado:

    Γ > M : σ  Γ > N : τ            Γ > M : σ × τ           Γ > M : σ × τ
    ____________________            ______________          ______________
    Γ > ⟨M, N⟩ : σ × τ              Γ > π1(M): σ            Γ > π2(M): τ


i. Adaptar el algoritmo de inferencia para que funcione sobre esta versión extendida

W(⟨U, V⟩) = 

W(U) = Γ > M : σ

Tener en cuenta un nuevo tipo par definido como: σ ::= . . . | σ × σ

Con expresiones nuevas definidas como: M ::= . . . | ⟨M, M⟩ | π1(M) | π2(M)

Y las siguientes reglas de tipado:

    Γ > M : σ  Γ > N : τ            Γ > M : σ × τ           Γ > M : σ × τ
    ____________________            ______________          ______________
    Γ > ⟨M, N⟩ : σ × τ              Γ > π1(M): σ            Γ > π2(M): τ


i. Adaptar el algoritmo de inferencia para que funcione sobre esta versión extendida

W(⟨U, V⟩) = S(Γ1) U S(Γ2) > S(⟨M, N⟩) : S(σ) × S(τ)

W(U) = Γ1 > M : σ

W(V) = Γ2 > N : τ

S = MGU{{σ1 ≐ σ2 | x : σ1 ∈ Γ1, x : σ2 ∈ Γ2}}


ii. Tipar la expresión (λf.hf,2i) (λx.x 1) utilizando la versión extendida del algoritmo


                                    (λf.⟨f, 2⟩) (λx.x 1) => ø > (λf : (Nat → t4) → t4.⟨f, 2⟩) (λx : Nat → t4.x 1) : ((Nat → t4) → t4) × Nat
                                           |
                                           | S = MGU {t1 → t1 × Nat ≐ ((Nat → t4) → t4) → t5}               =  
                                           |          {t1 ≐ (Nat → t4) → t4, t1 × Nat ≐ t5}                 = 
                                           |          {((Nat → t4) → t4) × Nat ≐ t5} | {(Nat → t4) → t4/t1} = 
                                           |          {} | {(Nat → t4) → t4/t1, ((Nat → t4) → t4) × Nat/ t5}
                ___________________________|___________________________
               |                                                       |
            λf.⟨f, 2⟩ ø > λf : t1.⟨f, 2⟩ : t1 → t1 × Nat             λx.x 1 => ø > λx : Nat → t4.x 1 : (Nat → t4) → t4
               |                                                       |
            ⟨f, 2⟩ =>  {f : t1} > ⟨f, 2⟩ : t1 × Nat                   x 1 => {x : Nat → t4} > x 1 : t4 
               |                                                       |
               |                                                       | S = MGU {t2 ≐ Nat → t4} = {Nat → t2/t4}
 ______________|______________                           ______________|______________
|                             |                         |                             |
f => {f : t1} > f : t1        2 => ø > 2 : Nat          x => {x : t2} > x : t2        1 => ø > 1 : Nat
                                                                                


iii.Intentar tipar la siguiente expresión utilizando la versión extendida del algoritmo.
                        
                                (λf.hf 2, f Truei) (λx.x)

Mostrar en qué punto del mismo falla y por qué motivo.


                                                                                (λf.⟨f 2, f True⟩) (λx.x)
                                                                                          |
                                                                                          |
                                         _________________________________________________|_________________________________________________
                                        |                                                                                                   |
                                        |                                                                                                   |   
                                        |                                                                                                   |
                                 λf.⟨f 2, f True⟩                                                                                         λx.x
                                        |                                                                                                   |
                                        |                                                                                                   |
                                        |                                                                                                   |
                                    ⟨f 2, f True⟩                                                                                           x
                                        |
                                        | S = MGU {Nat → t3 ≐ Bool → t4} = {Nat ≐ Bool, t3 ≐ t4} ERROR (Colisión)
               _________________________|_________________________
              |                                                   |
              |                                                   |                                                                        
              |                                                   |  
             f 2 => {f : Nat → t3} > f 2 : t3                   f True => {f : Bool → t4} > f True : t4 
              |                                                   |
              | S = MGU {t1 ≐ Nat → t3} = {Nat → t3/t1}           | S = MGU {t2 ≐ Bool → t4} = {Bool → t4/t2}
  ____________|____________                           ____________|____________
 |                         |                         |                         |    
 |                         |                         |                         |
 |                         |                         |                         | 
 f => {f : t1} > f : t1    2 => ø > 2 : Nat          f => {f : t2} > f : t2  True => ø > True : Bool



10) EITHER Y MAYBE OTRA VEZ https://streamscheme.com/wp-content/uploads/2020/04/NotLikeThis.png

a) Extender el sistema de tipado y el algoritmo de inferencia con las reglas necesarias para introducir los tipos Either σ σ y Maybe σ, cuyos términos son análogos a los de Haskell.

b) Utilizando estas reglas y el método del árbol, tipar la expresión:
        
            λx.if x then Just (Left 0) else Nothing



11) Extender el algoritmo de inferencia para soportar la inferencia de tipos de árboles binarios. En esta extensión del algoritmo sólo se considerarán los constructores del árbol.

La sintaxis de esta extensión es la siguiente:
                                                    σ ::= ... | ABσ M ::= ... | Nilσ | Bin(M, N, O)

Y sus reglas de tipado, las siguientes:

                                                                                    Γ > M : AB_σ  Γ > O : AB_σ  Γ > N : σ
                                    _________________                               ______________________________________
                                    Γ >  Nil_σ : AB_σ                               Γ > Bin(M, N, O) : AB_σ

Nota: la función Erase, que elimina la información de tipos que el inferidor se encargará de inferir, se extiende de manera acorde para la sintaxis nueva:

                                                    Erase(Nil_σ) = Nil
                                                    Erase(Bin(M, N, O)) = Bin(Erase(M),Erase(N),Erase(O))

Recordar que una entrada válida para el algoritmo es un pseudo término con la información de tipos eliminada. Por ejemplo:

                                                    (λx.Bin(Nil, 5, Bin(Nil, x, Nil))) 5



W(Nil) = ø > Nil_t1 : AB_t1


W(Bin(U, V, T)) = S(Γ1) ∪ S(Γ2) ∪ S(Γ3) > S(Bin(M, N, O)) : S(µ) 

W(U) = Γ1 > M : σ
W(V) = Γ2 > N : ð
W(T) = Γ3 > O : µ

S = MGU {µ ≐ AB_τ, σ ≐ AB_τ, µ ≐ σ, ð ≐ τ} ∪ {σ1 ≐ σ2 | x : σ1 ∈ Γi, x : σ2 ∈ Γj, i, j ∈ {1, 2, 3}}
 

b) Escribir la regla de tipado para el case de árboles binarios, y la regla análoga en el algoritmo de inferencia.




