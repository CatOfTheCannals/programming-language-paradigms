                                                                        INFERENCIA

1) Determinar qué expresiones son sintácticamente válidas y, para las que sean, indicar a qué gramática pertenecen.

PREGUNTA: los términos formados por variables de tipo son válidos en el cálculo lambda sin anotaciones o funcionan como un recurso para el algoritmo? Por ejemplo, λx: s1 → s2.if 0 then True else 0 succ(True)

______________________________________________________Válidas______________________________________________________
                
                Generadas por M                    Generadas por σ             Generadas por M'

                λx: Bool.succ(x)                       s → σ                     λx.isZero(x)
                
                                                         s
                                                        
                                                    s → (Bool → t)





_____________________________________________________Inválidas_____________________________________________________
                
                                                    Erase(f y) => Erase es parte de las expresiones asociadas al algoritmo de inferencia pero no forma parte de las del
                                                                                                                                                               lenguaje
                                           Erase(λf : Bool → s.λy : Bool.f y)
        


2) Determinar el resultado de aplicar la sustitución S a las siguientes expresiones.


i. S = {t ← Nat}    S({x : t → Bool}) => x : Nat → Bool

ii. S = {t1 ← t2 → t3, t ← Bool}    S({x : t → Bool}) > S(λx: t1 → Bool.x): S(Nat → t2) => {x : Bool → Bool} > (λx: t2 → t3 → Bool.x) : Nat → t2



3) Determinar el resultado de aplicar el MGU ("most general unifier") sobre las ecuaciones planteadas a continuación.

En caso de tener éxito, mostrar la sustitución resultante. 


i. MGU {t1 → t2 ≐ Nat → Bool} =1=> {t1 ≐ Nat, t2 ≐ Bool} =4=> {t2 ≐ Bool} | {Nat/t1} =4=> {} | {Bool/t2} ◦ {Nat/t1}  

ii. MGU {t1 → t2 ≐ t3} =3=> {t3 ≐ t1 → t2} =4=> {} | {t1 → t2/t3}

iii. MGU {t1 → t2 ≐ t2} =6=> ERROR

iv. MGU {(t2 → t1) → Bool ≐ t2 → t3} =1=> {t2 → t1 ≐ t2, t1 ≐ t3} =6=> ERROR 

v. MGU {t2 → t1 → Bool ≐ t2 → t3} =1=> {t2 ≐ t2, t1 → Bool ≐ t3} =2=> {t1 → Bool ≐ t3} =3=> {t3 ≐ t1 → Bool} =4=> {} | {t1 → Bool/t3}
                                                     
                                                 PREGUNTA: van paréntesis o no en el reemplazo de t1 por t2 → t3? @paréntesis
vi. MGU {t1 → Bool ≐ Nat → Bool, t1 ≐ t2 → t3} =4=> {(t2 → t3) → Bool ≐ Nat → Bool} | {t2 → t3/t1} =1=> {t2 → t3 ≐ Nat, Bool ≐ Bool} | {t2 → t3/t1} =5=> ERROR

vii. MGU {t1 → Bool ≐ Nat → Bool, t2 ≐ t1 → t1} =4=> {t1 → Bool ≐ Nat → Bool} | {t1 → t1/t2} =1=> {t1 ≐ Nat, Bool ≐ Bool} | {t1 → t1/t2} =4=> {Bool ≐ Bool} | {Nat/t1} ◦ {t1 → t1/t2} =2=> {} | {Nat/t1} ◦ {t1 → t1/t2} PREGUNTA: es correcto dejarlo así o debería aplicar Nat/t1 sobre todo lo que ya tenía? 

                                                         PREGUNTA: misma duda de paréntesis pero con el reemplazo de t3 por t2 → t1 @paréntesis
                                                                   si pongo paréntesis, queda t1 ≐ t2 → t1 y t2 ≐ t4 => ERROR
                                                                   si no pongo, tengo t1 ≐ t2 y t2 ≐ t1 → t4 =4=> t1 ≐ t1 → t4 =6=> ERROR
viii. MGU {t1 → t2 ≐ t3 → t4, t3 ≐ t2 → t1} =4=> {t1 → t2 ≐ (t2 → t1) → t4} | {t2 → t1/t3} =1=> {t1 ≐ t2 → t1, t2 ≐ t4} | {t2 → t1/t3} =6=> ERROR



4) Unir con flechas los tipos que unifican entre sí (entre una fila y la otra). Para cada par unificable, exhibir el mgu ("most general unifier").

t → u                   Nat                     u → Bool                    a → b → c


t                       Nat → Bool              (Nat → u) → Bool            Nat → u → Bool



t → u       con Nat → Bool          => {Nat/t, Bool/u}
            con u → Bool            => PREGUNTA: no se puede porque no hay un orden particular de la aplicación? Por ejemplo, {u/t, Bool/u} => Se puede: RECORDAR CORRER EL ALGORITMO SOBRE LA UNIFICACIÓN
            con (Nat → u) → Bool    => Idem anterior pero con {Nat → u/t, Bool/u}
            con Nat → u → Bool      => Idem anterior 
            con a → b → c           => PREGUNTA: Cuál es el mgu: {a/t, b → c/u} o {a → b/t, c/u}?

u → Bool    con Nat → Bool          => {Nat/u}

a → b → c   con (Nat → u) → Bool    => PREGUNTA: para lograr unificarlos debería ser posible agregar paréntesis, solamente se agregan cuando se reemplaza una variable 
                                                 por un tipo función? @paréntesis
   
t           con Nat                 => {Nat/t}
            con Nat → Bool          => {Nat → Bool/t}
            con u → Bool            => {u → Bool/t}
            con (Nat → u) → Bool    => {(Nat → u) → Bool/t}
            con a → b → c           => {a → b → c/t}
            con Nat → u → Bool      => {Nat → u → Bool/t}



5) Decidir, utilizando el método del árbol, cuáles de las siguientes expresiones son tipables. Mostrar qué reglas y sustituciones se aplican en cada paso y justificar por qué no son tipables aquéllas que fallan.

i. λz. if z then 0 else succ(0)

                                                                    λz. if z then 0 else succ(0) =>  ø > λz : Bool. if z then 0 else succ(0) : Bool → Nat
                                                                                 |
                                                                        if z then 0 else succ(0) => {z : Bool} > if z then 0 else succ(0) : Nat 
                                                                                 |
                                                                                 |               
                                                                                 | S = MGU {Nat ≐ Nat, t1 ≐ Bool} = {Bool/t1}
                                                                                 |
                         ________________________________________________________|________________________________________________________
                        |                                                        |                                                        |
                        z => {z : t1} > z : t1                                  0 => ø > 0 : Nat                                       succ(0) => ø > succ(0) : Nat
                                                                                                                                          |
                                                                                                                                          0 => ø > 0 : Nat



ii. λy. succ((λx.x) y)

                                                                    λy. succ((λx.x) y) => ø > λy : Nat. succ((λx.x) y) : Nat → Nat
                                                                            |
                                                                        succ((λx.x) y) => {y : Nat} > succ((λx.x) y) : Nat 
                                                                            |
                                                                            | S = MGU {t1 ≐ Nat} = {Nat/t1}
                                                                            |
                                                                         (λx.x) y => {y : t1} > (λx.x) y : t1  
                                                                            |
                                                                            | S = MGU {t1 → t1 ≐ t3 → t4} = {t1 ≐ t3, t1 ≐ t4} = {t1/t3, t1/t4}
                                    ________________________________________|________________________________________
                                   |                                                                                 |
                                  λx.x => ø > λx : t1.x : t1 → t1                                                    y => {y : t3} > y : t3
                                   |
                                   x => {x : t1} > x : t1  



iii. λx. if isZero(x) then x else (if x then x else x)


                        λx. if isZero(x) then x else (if x then x else x)
                                              |
                            if isZero(x) then x else (if x then x else x)
                                              |
                                              | S = MGU {Nat ≐ Bool, t5 ≐ Bool} => ERROR
       _______________________________________|_______________________________________
      |                                       |                                       |
   isZero(x) => {x : Nat} > isZero(x) : Bool  x => {x : t5} > x : t5        (if x then x else x) => {x : Bool} > (if x then x else x) : Bool 
      |                                                                               |
      x {x : t4} > x : t4                                                             |  S = MGU {t1 ≐ Bool, t1 ≐ t2, t2 ≐ t3, t1 ≐ t3} = {Bool/t1, Bool/t2, Bool/t3}
                                                               _______________________|_______________________       
                                                              |                       |                       |
                                                              x => {x : t1} > x : t1  x => {x : t2} > x : t2  x => {x : t3} > x : t3



iv. λx.λy. if x then y else succ(0)

                λx.λy. if x then y else succ(0) => ø > λx : Bool.λy : Nat. if x then y else succ(0) : Bool → Nat → Nat  
                            |
                   λy. if x then y else succ(0) => {x : Bool} > λy : Nat. if x then y else succ(0) : Nat → Nat 
                            |
                       if x then y else succ(0) => {x : Bool, y : Nat} > if  then y else succ(0) : Nat
                            |
                            | S = MGU {t2 ≐ Bool, t1 ≐ Nat} = {Bool/t2, Nat/t1} 
 ___________________________|___________________________
|                           |                           |
x => {x : t2} > x : t2      y => {y : y1} > y : t1   succ(0) => ø > succ(0) : Nat
                                                        |
                                                        0 => ø > 0 : Nat


Quedan para el lector (?
_________________________________________________
v. if True then (λx. 0) 0 else (λx. 0) False     |
vi. (λf. if True then f 0 else f False) (λx. 0)  |
vii. λx.λy.λz. if z then y else succ(x)          |
_________________________________________________|


viii. fix (λx. pred(x))

Para el punto viii, asumir extentido el algoritmo de inferencia con W(fix) = ∅ > fix_a : (a → a) → a donde a es una variable fresca.

                        fix (λx. pred(x)) => ø > fix (λx. pred(x)) : Nat 
                                |
                                | S = MGU {Nat → Nat ≐ t2 → t2} = {Nat ≐ t2, Nat ≐ t2} = {Nat ≐ t2} = {Nat/t2}
                                |
                             λx. pred(x) => ø > λx : Nat. pred(x) : Nat → Nat
                                |
                              pred(x) => {x : Nat} > pred(x) : Nat 
                                |
                                | S = MGU {t1 ≐ Nat} = {Nat/t1}
                                |
                                x => {x : t1} > x : t1



6) 

i. λx. λy. λz. (z x) y z

    PREGUNTA: podrían no estar los paréntesis y conservar la semántica?

                                                                      λx. λy. λz. (z x) y z
                                                                                |
                                                                        λy. λz. (z x) y z
                                                                                |
                                                                           λz. (z x) y z
                                                                                |
                                                                            (z x) y z
                                                                                |                                                   @paréntesis
                                                                                | S = MGU {t6 ≐ t2 → t4 → t5, t5 ≐ t6 → t7} = {t5 ≐ (t2 → t4 → t5) → t7} | {t2 → t4 → t5/ t6} => ERROR 
                                            ____________________________________|____________________________________
                                           |                                                                         |
                                        (z x) y => {z : t2 → t4 → t5, x : t2} > (z x) y : t5                         z => {z : t6} > z : t6
                                           |
                                           | S = MGU {t3 ≐ t4 → t5} = {t4 → t5/t3}
                       ____________________|____________________
                      |                                         |
                     z x => {z : t2 → t3, x : t2} > z x : t3    y => {y : t4} > y : t4
                      |
                      | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/ t1}
  ____________________|____________________
 |                                         |
 z => {z : t1} > z : t1                    x => {x : t2} > x : t2


Para el lector parte 2.
_________________________
ii.                      |
...                      |
vii.                     |
_________________________|



7) Indicar tipos σ y τ apropiados de modo que los términos de la forma λy : σ.λx : τ.y^n(x) resulten tipables para todo n natural. El par (σ, τ) debe ser el mismo para todos los términos. Observar si tienen todos el mismo tipo. Notación: M^0(N) = N, M^(n+1)(N) = M(M^n(N)). Sugerencia: empezar haciendo inferencia para n = 2 (es decir, calcular W(λy.λx.y(yx))) y generalizar el resultado.


                                                                            λy.λx.y(yx) => ø > λy : t3 → t3.λx : t3.y(yx) : (t3 → t3) → t3 → t3 
                                                                                |
                                                                             λx.y(yx) => {y : t3 → t3} > λx : t3.y(yx) : t3 → t3 
                                                                                |
                                                                              y(yx) => {y : t3 → t3, x : t3} > y(yx) : t3
                                                                                |
                                                                                | S = MGU {t4 ≐ t2 → t3, t4 ≐ t3 → t5} = {t2 → t3 ≐ t3 → t5} | {t2 → t3/t4} = {t2 → t3/t4, t3/t2, t3/t5}
                                                                   _____________|_____________
                                                                  |                           |
                                                                  y => {y : t4} > y : t4     yx => {y : t2 → t3, x : t2} > y x : t3
                                                                                              |
                                                                                              | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/t1}
                                                                                 _____________|_____________
                                                                                |                           |
                                                                                y => {y : t1} > y : t1      x => {x : t2} > x :t2



Dado que y toma elementos de su imagen como argumento (ya que se puede hacer y(yx)), entonces los tipos del dominio y la imágen deben coincidir (t3 → t3). Por otro lado, como x es pasado como argumento de y, debe tener el tipo que acepta y (t3). Finalmente, debido a que la lambda es una aplicación anidada de y, el tipo de salida es el de la imagen de y (t3).

En general, tomando (σ, τ) = (t3 → t3, t3) se consigue lo que se quiere.

Todos los términos tienen el mismo tipo ya que los tipos de los argumentos no cambian aunque lo haga el subtérmino de la lambda. Es decir, continúa recibiendo una función de tipo t3 → t3, una variable de tipo t3 y devuelve algo de tipo t3.

PREGUNTA: es necesaria la demostración por inducción?

Sean M : t3 → t3 y N : t3. Supongo que vale que M^k(N) : t3, con k >= 2, entonces, si R = M^k(N), por E-App vale M R : t3. Es decir, M(M^k(N)) : t3 => M^(k+1)(N) : t3.  



8) 

PREGUNTA: qué pasa si me quedan variables de tipo al terminar la aplicación del algoritmo? reemplazo por tipos genéricos? NO! DEVUEVLO ASÍ 

                                                                                λy.(x y) (λz.x2) => {x : t2 → (t5 → t4) → t7, x2 : t4} > λy : t2.(x y) (λz.x2) : t2 → t7
                                                                                        |
                                                                                   (x y) (λz.x2) => {x : t2 → (t5 → t4) → t7, y : t2, x2 : t4} > (x y) (λz.x2) : t7 
                                                                                        |
                                                                                        | S = MGU {t3 ≐ (t5 → t4) → t7} = {(t5 → t4) → t7/t3}
                                            ____________________________________________|____________________________________________
                                           |                                                                                         |
                                          x y => {x : t2 → t3, y : t2} > x y : t3                                                  λz.x2 => {x2 : t4} > λz : t5.x2 : t5 → t4
                                           |                                                                                         |   
                                           | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/t1}                                                  x2 => {x2 : t4} > x2 : t4
                           ________________|________________                                                                         
                          |                                 |                                                                        
                          x => {x : t1} > x : t1            y => {y : t2} > y : t2





{x : t2 → (t5 → t4) → t7, x2 : t4} > λy : t2.(x y) (λz.x2) : t2 → t7



9)

Tener en cuenta un nuevo tipo par definido como: σ ::= . . . | σ × σ

Con expresiones nuevas definidas como: M ::= . . . | ⟨M, M⟩ | π1(M) | π2(M)

Y las siguientes reglas de tipado:

    Γ > M : σ  Γ > N : τ            Γ > M : σ × τ           Γ > M : σ × τ
    ____________________            ______________          ______________
    Γ > ⟨M, N⟩ : σ × τ              Γ > π1(M): σ            Γ > π2(M): τ


i. Adaptar el algoritmo de inferencia para que funcione sobre esta versión extendida

W(⟨U, V⟩) = 

W(U) = Γ > M : σ

Tener en cuenta un nuevo tipo par definido como: σ ::= . . . | σ × σ

Con expresiones nuevas definidas como: M ::= . . . | ⟨M, M⟩ | π1(M) | π2(M)

Y las siguientes reglas de tipado:

    Γ > M : σ  Γ > N : τ            Γ > M : σ × τ           Γ > M : σ × τ
    ____________________            ______________          ______________
    Γ > ⟨M, N⟩ : σ × τ              Γ > π1(M): σ            Γ > π2(M): τ


i. Adaptar el algoritmo de inferencia para que funcione sobre esta versión extendida

W(⟨U, V⟩) = S(Γ1) ∪ S(Γ2) > S(⟨M, N⟩) : S(σ) × S(τ)

W(U) = Γ1 > M : σ

W(V) = Γ2 > N : τ

S = MGU{{σ1 ≐ σ2 | x : σ1 ∈ Γ1, x : σ2 ∈ Γ2}}


W(π1(U)) = S(Γ) > S(π1(M)) : S(t1) 

W(U) = Γ > M : σ

S = MGU {σ ≐ t1 × t2}


W(π2(V)) = S(Γ) > S(π2(N)) : S(t2) 

W(V) = Γ > N : σ

S = MGU {σ ≐ t1 × t2}



ii. Tipar la expresión (λf.hf,2i) (λx.x 1) utilizando la versión extendida del algoritmo


                                    (λf.⟨f, 2⟩) (λx.x 1) => ø > (λf : (Nat → t4) → t4.⟨f, 2⟩) (λx : Nat → t4.x 1) : ((Nat → t4) → t4) × Nat
                                           |
                                           | S = MGU {t1 → t1 × Nat ≐ ((Nat → t4) → t4) → t5}               =  
                                           |          {t1 ≐ (Nat → t4) → t4, t1 × Nat ≐ t5}                 = 
                                           |          {((Nat → t4) → t4) × Nat ≐ t5} | {(Nat → t4) → t4/t1} = 
                                           |          {} | {(Nat → t4) → t4/t1, ((Nat → t4) → t4) × Nat/ t5}
                ___________________________|___________________________
               |                                                       |
            λf.⟨f, 2⟩ ø > λf : t1.⟨f, 2⟩ : t1 → t1 × Nat             λx.x 1 => ø > λx : Nat → t4.x 1 : (Nat → t4) → t4
               |                                                       |
            ⟨f, 2⟩ =>  {f : t1} > ⟨f, 2⟩ : t1 × Nat                   x 1 => {x : Nat → t4} > x 1 : t4 
               |                                                       |
               |                                                       | S = MGU {t2 ≐ Nat → t4} = {Nat → t2/t4}
 ______________|______________                           ______________|______________
|                             |                         |                             |
f => {f : t1} > f : t1        2 => ø > 2 : Nat          x => {x : t2} > x : t2        1 => ø > 1 : Nat
                                                                                


iii.Intentar tipar la siguiente expresión utilizando la versión extendida del algoritmo.
                        
                                (λf.hf 2, f Truei) (λx.x)

Mostrar en qué punto del mismo falla y por qué motivo.


                                                                                (λf.⟨f 2, f True⟩) (λx.x)
                                                                                          |
                                                                                          |
                                         _________________________________________________|_________________________________________________
                                        |                                                                                                   |
                                        |                                                                                                   |   
                                        |                                                                                                   |
                                 λf.⟨f 2, f True⟩                                                                                         λx.x
                                        |                                                                                                   |
                                        |                                                                                                   |
                                        |                                                                                                   |
                                    ⟨f 2, f True⟩                                                                                           x
                                        |
                                        | S = MGU {Nat → t3 ≐ Bool → t4} = {Nat ≐ Bool, t3 ≐ t4} ERROR (Colisión)
               _________________________|_________________________
              |                                                   |
              |                                                   |                                                                        
              |                                                   |  
             f 2 => {f : Nat → t3} > f 2 : t3                   f True => {f : Bool → t4} > f True : t4 
              |                                                   |
              | S = MGU {t1 ≐ Nat → t3} = {Nat → t3/t1}           | S = MGU {t2 ≐ Bool → t4} = {Bool → t4/t2}
  ____________|____________                           ____________|____________
 |                         |                         |                         |    
 |                         |                         |                         |
 |                         |                         |                         | 
 f => {f : t1} > f : t1    2 => ø > 2 : Nat          f => {f : t2} > f : t2  True => ø > True : Bool



10) EITHER Y MAYBE OTRA VEZ https://streamscheme.com/wp-content/uploads/2020/04/NotLikeThis.png

a) Extender el sistema de tipado y el algoritmo de inferencia con las reglas necesarias para introducir los tipos Either σ σ y Maybe σ, cuyos términos son análogos a los de Haskell.

b) Utilizando estas reglas y el método del árbol, tipar la expresión:
        
            λx.if x then Just (Left 0) else Nothing



11) Extender el algoritmo de inferencia para soportar la inferencia de tipos de árboles binarios. En esta extensión del algoritmo sólo se considerarán los constructores del árbol.

La sintaxis de esta extensión es la siguiente:
                                                    σ ::= ... | ABσ M ::= ... | Nilσ | Bin(M, N, O)

Y sus reglas de tipado, las siguientes:

                                                                                    Γ > M : AB_σ  Γ > O : AB_σ  Γ > N : σ
                                    _________________                               ______________________________________
                                    Γ >  Nil_σ : AB_σ                               Γ > Bin(M, N, O) : AB_σ

Nota: la función Erase, que elimina la información de tipos que el inferidor se encargará de inferir, se extiende de manera acorde para la sintaxis nueva:

                                                    Erase(Nil_σ) = Nil
                                                    Erase(Bin(M, N, O)) = Bin(Erase(M),Erase(N),Erase(O))

Recordar que una entrada válida para el algoritmo es un pseudo término con la información de tipos eliminada. Por ejemplo:

                                                    (λx.Bin(Nil, 5, Bin(Nil, x, Nil))) 5



W(Nil) = ø > Nil_t1 : AB_t1


W(Bin(U, V, T)) = S(Γ1) ∪ S(Γ2) ∪ S(Γ3) > S(Bin(M, N, O)) : S(µ) 

W(U) = Γ1 > M : σ
W(V) = Γ2 > N : ð
W(T) = Γ3 > O : µ

S = MGU {µ ≐ AB_τ, σ ≐ AB_τ, µ ≐ σ, ð ≐ τ} ∪ {σ1 ≐ σ2 | x : σ1 ∈ Γi, x : σ2 ∈ Γj, i, j ∈ {1, 2, 3}}
 

b) Escribir la regla de tipado para el case de árboles binarios, y la regla análoga en el algoritmo de inferencia.


Γ > M : AB_τ   Γ U {l : AB_τ, r : AB_τ, v : τ} > O : σ   Γ > N : σ  
___________________________________________________________________(T-CaseBin)
Γ > case M of {Nil ~~> N | Bin(l, v, r) ~~> O} : σ


PREGUNTA: qué es la regla análoga a una relga de tipado?

W(case U of {Nil ~~> V | Bin(l, v, r) ~~> W}) = S(Γ1) ∪ S(Γ2) ∪ S(Γ3') > S(case M of {Nil ~~> N | Bin(l, v, r) ~~> O}) : S(µ)

W(U) = Γ1 > M : σ
W(V) = Γ2 > N : ð
W(W) = Γ3 > O : µ

τ_l | α si l : α ∈ Γ3
    | s variable fresca si no

τ_v | β si v : β ∈ Γ3
    | s variable fresca si no

τ_r | ŋ si r : ŋ ∈ Γ3
    | s variable fresca si no

S = MGU {σ ≐ AB_(τ_v), µ ≐ ð, σ ≐ τ_r, σ ≐ τ_l} ∪ {σ1 ≐ σ2 | x : σ1 ∈ Γi, x : σ2 ∈ Γj, i, j ∈ {1, 2, 3'}}
 
Γ3' = Γ3 ⊖ {l, v, r} (elimina la información de tipo relacionada con l, v y r, y deja el resto igual)



12) Extender el algoritmo de inferencia W para que soporte el tipado del switch de números naturales, similar al de C o C++. La extensión de la sintaxis es la siguiente:

                                        M = . . . | switch M {case n1 : M1 . . . case nk : Mk default : Mk+1}

donde cada ni es un numeral (un valor de tipo Nat, como 0, succ(0), succ(succ(0)), etc.). Esto forma parte de la sintaxis y no hace falta verificarlo en el algoritmo.
La regla de tipado es la siguiente:

                                        Γ > M : Nat   ∀i, j(1 ≤ i, j ≤ k ∧ i ≠ j ⇒ ni ≠ nj)   Γ > N1 : σ ... Γ > Nk : σ   Γ > N : σ
                                        _______________________________________________________________________________________________
                                        Γ > switch M {case n1 : N1 ... case nk : Nk default : N} : σ


W(switch U {case n1 : V1 ... case nk : Vk default : V}) = S(Γu) ∪ S(Γ1) ∪ ... ∪ S(Γk) ∪ S(Γv) > S(switch M {case n1 : N1 ... case nk : Nk default : N}) : S(τ)

Debe cumplirse ∀i, j(1 ≤ i, j ≤ k ∧ i ≠ j ⇒ ni ≠ nj)

W(U) = Γu > M : σ

W(V1) = Γ1 > N1 : τ1
...
W(Vk) = Γk > Nk : τk

W(V) = Γv > N : τ

S = MGU {σ ≐ Nat, τ1 ≐ τ, τ2 ≐ τ, ... , τk ≐ τ} ∪ {σ1 ≐ σ2 | x : σ1 ∈ Γi, x : σ2 ∈ Γj, i, j ∈ {1, ... ,k} ∪ {u, v}}



13)

En este ejercicio extenderemos el algoritmo de inferencia para soportar operadores binarios. Dichos operadores se comportan de manera similar a las funciones, excepto que siempre tienen 2 parámetros y su aplicación se nota de manera infija. Para esto extenderemos la sintaxis y el sistema de tipos del cálculo lambda tipado de la
siguiente manera:

                                        M ::= ... | ϕx : σ y : τ.M | ⟨M N O⟩ 
                                        
                                        σ ::= ... | Op(σ, τ → υ)

Aquí ϕ es el constructor de operadores que liga las variables x (parámetro anterior al operador) e y (parámetro posterior) y ⟨M N O⟩ es la aplicación del operador N a los parámetros M y O (lo ponemos entre h y i para evitar problemas de ambigüedad con la aplicación estándar). Op(σ, τ → υ), por otro lado, representa el tipo de
los operadores cuyo parámetro anterior es de tipo σ, el posterior de tipo τ y dan como resultado un tipo υ.

Las reglas de tipado que se incorporan son las siguientes:

Γ ∪ {x: σ, y : τ} > M : υ                                   Γ > M : σ   Γ > N : Op(σ, τ → υ)   Γ > O : τ                                        
_________________________________                           _______________________________________________
Γ > ϕx : σ y : τ.M : Op(σ, τ → υ)                           Γ > ⟨M N O⟩ : υ


i. Dar la extensión al algoritmo necesaria para soportar el tipado de las nuevas expresiones. Recordar que el parámetro de entrada es un término sin anotaciones de tipos.

W(ϕx y .U) = Γ' > ϕx : τ_x y : τ_y.M : Op(τ_x, τ_y → σ)

W(U) = Γ > M : σ

τ_x | α si x : α ∈ Γ
    | s variable fresca si no

τ_y | β si y : β ∈ Γ
    | s variable fresca si no
 
Γ' = Γ ⊖ {x, y}


W(⟨U V W⟩) = S(Γ1) ∪ S(Γ2) ∪ S(Γ3) > S(⟨M N O⟩) : S(t)

W(U) = Γ1 > M : σ1
W(V) = Γ2 > N : σ2
W(W) = Γ3 > O : σ3

S = MGU {σ2 ≐ Op(σ1, σ3 → t)} ∪ {σ4 ≐ σ5 | x : σ4 ∈ Γi, x : σ5 ∈ Γj, i, j ∈ {1, 2, 3}}


ii. Aplicar el algoritmo extendido con el método del árbol para tipar: ⟨(λx.succ(x)) (ϕxy.xy) 0⟩

                                                                ⟨(λx.succ(x)) (ϕxy.xy) 0⟩ => ø > ⟨(λx : Nat.succ(x)) (ϕx : Nat → Nat y : Nat. x y) 0⟩ : Nat
                                                                             |
                                                                             | S = MGU {Op(t2 → t3, t2  →  t3) ≐ Op(Nat → Nat, Nat  →  t)} =
                                                                             |         {t2 → t3 ≐ Nat → Nat, t2 ≐ Nat, t3 ≐ t} | {}
                                                                             |         {t2 ≐ Nat, t3 ≐ Nat, t2 ≐ Nat, t3 ≐ t} | {}
                                                                             |         {t3 ≐ Nat, Nat ≐ Nat, t3 ≐ t} | {Nat/t2}
                                                                             |         {Nat ≐ t} | {Nat/t2, Nat/t3}
                                                                             |         {} | {Nat/t2, Nat/t3, Nat/t}
                            _________________________________________________|______________________________________________________________________
                           |                                                 |                                                                      |
                           |                                                 |                                                                      |
                           |                                                 |                                                                      |
                        λx.succ(x) => ø > λx : Nat.succ(x) : Nat → Nat    ϕxy.xy ø > ϕx : t2 → t3 y : t2. x y : Op(t2 → t3, t2  →  t3)              0 ø > 0 : Nat
                           |                                                 |                                                 
                           |                                                 |                                                  
                           |                                                 |                                                 
                        succ(x) => {x : Nat} > succ(x) : Nat                x y => {x : t2 → t3, y : t2} > x y : t3
                           |                                                 |                                                 
                           | S = MGU {t4 ≐ Nat} = {} | {Nat/t4}              | S = MGU {t1 ≐ t2 → t3} = {} | {t2 → t3/t1}
                           |                              ___________________|___________________                                                 
                           x => {x : t4} > x : t4        |                                       |
                                                         x => {x : t1} > x : t1                  y => {y : t2} > y : t2



14)

Considerar el algoritmo de inferencia extendido para soportar listas:

                                        W([]) = ∅ > []t : [t], con t variable fresca.

                                        W(M : N) = SΓ1 ∪ SΓ2 > S(U : V) : [Sσ], con:

                                        W(M) = Γ1 . U : σ
                                        W(N) = Γ2 . V : τ

                                        S = MGU({τ ≐ [σ]} ∪ {α ≐ β | x : α ∈ Γ1 ∧ x : β ∈ Γ2})

i. Extender el algoritmo de inferencia para soportar expresiones de la forma "∃x in M/N".

                                        Γ ∪ {x : σ} > N : Bool   Γ > M : [σ]
                                        _____________________________________
                                        Γ > ∃x in M/N : Bool

W(∃x in U/V) = S(Γ1) ∪ S(Γ2') > S(∃x in M/N) : Bool 

W(U) = Γ1 > M : σ
W(V) = Γ2 > N : τ

τ_x | α si x : α ∈ Γ2
    | s variable fresca si no 

S = MGU {σ ≐ [τ_x], τ ≐ Bool} ∪ {σ1 ≐ σ2 | x : σ1 ∈ Γ1, x : σ2 ∈ Γ2'}

Γ2' = Γ2 ⊖ {x}


ii. Aplicar el algoritmo extendido con el método del árbol para tipar las siguientes expresiones. Si alguna de ellas no tipa, indicar el motivo.

    i) (λx.∃y in x/y)(0 : [ ])


                                                                (λx.∃y in x/y)(0 : [ ])
                                                                           |
                                                                           | S = MGU {[Bool] → Bool ≐ [Nat] → t4} = {[Bool] ≐ [Nat], Bool ≐ t4} ERROR (Colisión)
                        ___________________________________________________|___________________________________________________
                       |                                                                                                       |
                       |                                                                                                       |
                       |                                                                                                       |
                  λx.∃y in x/y => ø > λx : [Bool].∃y in x/y : [Bool] → Bool                                                  0 : [] => ø > 0 : []_Nat : [Nat]   
                       |                                                                                                       |
                       |                                                                                                       | S = MGU {t3 ≐ [Nat]} = {} | {[Nat]/t3}
                       |                                                                                            ___________|___________
                    ∃y in x/y => {x : [Bool]} > ∃y in x/y : Bool                                                   |                       |
                       |                                                                                           0 => ø > 0 : Nat       [] => ø > []_t3 : [t3] 
                       | S = MGU {t1 ≐ [t2], t2 ≐ Bool} = {t1 ≐ [Bool]} | {Bool/t2} = {} | {Bool/t2, [Bool]/t1} 
            ___________|___________
           |                       |
           x => {x : t1} > x : t1  y => {y : t2} > y : t2


    ii) (λx.∃y in x/y)(iszero(z) : [ ])

                                                    (λx.∃y in x/y)(iszero(z) : [ ]) => {z : Nat} > (λx : [Bool].∃y in x/y)(iszero(z) : [ ]) : Bool
                                                               |
                                                               | S = MGU {[Bool] → Bool ≐ [Bool] → t5} = {[Bool] ≐ [Bool], Bool ≐ t5} = {} | {Bool/t5}
            ___________________________________________________|___________________________________________________
           |                                                                                                       |
           |                                                                                                       |
           |                                                                                                       |
      λx.∃y in x/y => ø > λx : [Bool].∃y in x/y : [Bool] → Bool                                          iszero(z) : [ ] => {z : Nat} >  iszero(z) : []_Bool : [Bool]   
           |                                                                                                       |
           |                                                                                                       | S = MGU {t4 ≐ [Bool]} = {} | {[Bool]/t4}
           |                                                                                    ___________________|___________________
        ∃y in x/y => {x : [Bool]} > ∃y in x/y : Bool                                           |                                       |
           |                                                                             iszero(z) => {z : Nat} > isZero(z) : Bool  [] => ø > []_t4 : [t4] 
           | S = MGU {t1 ≐ [t2], t2 ≐ Bool} =                                                  |
           |         {t1 ≐ [Bool]} | {Bool/t2} =                                               |
           |         {} | {Bool/t2, [Bool]/t1}                                                 | S = MGU {t3 ≐ Nat} = {} | {Nat/t3}
 __________|____________                                                                       | 
|                       |                                                                      |
x => {x : t1} > x : t1  y => {y : t2} > y : t2                                                 z => {z : t3} > z : t3
                                        

    iii) ∃x in [ ]/True

                                                                            ∃x in [ ]/True => ø > ∃x in []_t2/True : Bool
                                                                                  |
                                                                                  | S = MGU {[t1] ≐ [t2], Bool ≐ Bool} = {t2/t1}
                                                         _________________________|_________________________
                                                        |                                                   |
                                                        [] => ø > []_t1 : [t1]                             True => ø > True : Bool
                                                        

    iv) ∃x in [ ]/(λy.True)

                                                                    ∃x in []/(λy.True) 
                                                                            |
                                                                            | S = MGU {[t1] ≐ [t3], Bool ≐ t2 → Bool} ERROR (Colisión)
                                                   _________________________|_________________________
                                                  |                                                   |
                                                 [] => ø > []_t1 : [t1]                           λy.True => ø > λy : t2.True : t2 → Bool
                                                                                                      |
                                                                                                     True => ø > True : Bool       
                                        

    v) ∃x in (0 : [ ])/iszero(x)

                                                                 ∃x in (0 : [ ])/iszero(x) => ø > ∃x in (0 : []_Nat)/iszero(x) : Bool 
                                                                            |
                                                                            | S = MGU {[Nat] ≐ [Nat], Bool ≐ Bool}
                                                   _________________________|_________________________
                                                  |                                                   |
                                                0 : [ ] => ø > 0 : []_Nat : [Nat]                  iszero(x) => {x : Nat} > isZero(x) : Bool
                                                  |                                                   |
                                                  | S = MGU {[t1] ≐ [Nat]} = {} | {Nat/t1}            | S = MGU {t2 ≐ Nat} = {} | {Nat/t2}
                         _________________________|_________________________                          |
                        |                                                   |                         x => {x : t2} > x : t2
                        0 => ø > 0 : Nat                                    [] => ø > []_t1 : [t1]


                     
15)

Se desea diseñar un algoritmo de inferencia de tipos para el cálculo λ extendido con fórmulas proposicionales de la siguiente manera:

                                        M ::= · · · | ¬M | M ⊃ M | esTautología(M) 
                                        
                                        σ := · · · | Prop
                                        
Las reglas de tipado son:

                                        Γ > M : Prop
                                        _____________(tNeg)
                                        Γ > ¬M : Prop           
                                        
                                        Γ > M : Prop   Γ > N : Prop
                                        ____________________________(tImp)
                                        Γ > M ⊃ N : Prop 

                                        Γ, x1 : Prop, . . . , xn :Prop > M : Prop   fv(M) = {x1, . . . , xn}
                                        _____________________________________________________________________(tTaut)
                                        Γ > esTautología(M): Bool

Notar que esTautología(M) liga todas las variables libres de M. Por ejemplo, esTautología(p ⊃ (q ⊃ p)) es un término cerrado y bien tipado (de tipo Bool).

i. Extender el algoritmo de inferencia para admitir las expresiones incorporadas al lenguaje, de tal manera que implemente las reglas de tipado tNeg, tImp y tTaut.


W(¬U) = S(Γ) > S(M) : S(σ)

W(U) = Γ > M : σ

S = MGU {σ ≐ Prop}


W(U ⊃ V) = S(Γ1) ∪ S(Γ2) > S(M ⊃ N) : Prop 

W(U) = Γ1 > M : σ1
W(V) = Γ2 > M : σ2

S = MGU {σ1 ≐ Prop, σ2 ≐ Prop} ∪ {σ3 ≐ σ4 | x : σ3 ∈ Γ1, x : σ4 ∈ Γ2}


W(esTautología(U)) = S(Γ') > esTautología(U) : Prop 

W(U) = Γ > M : σ

τ_x1 | α si x1 : α ∈ Γ
     | s variable fresca si no
...
τ_xn | α si xn : α ∈ Γ
     | s variable fresca si no

S = MGU {σ ≐ Prop, τ_x1 ≐ Prop, ... , τ_xn ≐ Prop} donde fv(M) = {x1, ... , xn}

Γ' = Γ ⊖ fv(M)

ii. Aplicar el algoritmo extendido con el método del árbol para tipar las siguientes expresiones (exhibiendo siempre las sustituciones utilizadas). Si alguna de ellas no tipa, indicar el motivo.

                                                            λy.¬((λx.¬x)(y ⊃ y)) => ø > λy : Prop.¬((λx : Prop.¬x)(y ⊃ y)) : Prop → Prop 
                                                                     |
                                                                     |
                                                                     | 
                                                             ¬((λx.¬x)(y ⊃ y)) => {y : Prop} > ¬((λx : Prop.¬x)(y ⊃ y)) : Prop
                                                                     |
                                                                     | 
                                                                     |
                                                               (λx.¬x)(y ⊃ y) => {y : Prop} > (λx : Prop.¬x)(y ⊃ y) : Prop 
                                                                     |
                                                                     | S = MGU {Prop → Prop ≐ Prop → t4} = {Prop ≐ Prop, Prop ≐ t4} | {} = {} | {Prop/t4}
                                        _____________________________|_____________________________
                                       |                                                           |
                                       |                                                           |
                                       |                                                           |
                                     λx.¬x => ø > λx.¬x : Prop → Prop                            y ⊃ y => {y : Prop} > y ⊃ y : Prop 
                                       |                                                           |
                                       |                                                           | S = MGU {t2 ≐ Prop, t3 ≐ Prop, t2 ≐ t3} = {} | {Prop/t2, Prop/t3}
                                       |                                             ______________|______________
                                      ¬x => {x : Prop} > ¬x : Prop                  |                             |
                                       |                                            |                             | 
                                       | S = MGU {t1 ≐ Prop} = {} | {Prop/t1}       |                             | 
                                       |                                            y => {y : t2} > y : t2        y => {y : t3} > y : t3
                                       x => {x : t1} > x : t1



    
                                                                            (λx.esTautología(if x then y else z))True
                                                                                            |
                                                                                            |
                                          __________________________________________________|__________________________________________________
                                         |                                                                                                     |
                          λx.esTautología(if x then y else z)                                                                               True
                                         |                          
                                         |
                                         |
                             esTautología(if x then y else z)
                                         |
                                         | S = MGU {t2 ≐ Prop, Bool ≐ Prop} = {Bool ≐ Prop} | {Prop/t2} ERROR(Colisión)
                                         |
                                    if x then y else z => {x : Bool, y : t2, z : t2} > if x then y else z : t2 
                                         |
                                         | S = MGU {t1 ≐ Bool, t2 ≐ t3} = {} | {Bool/t1, t2/t3}
                 ________________________|________________________
                |                        |                        |
                x => {x : t1} > x : t1   y => {y : t2} > y : t2   z => {z : t3} > z : t3                  



16)

En este ejercicio consideramos dada la extensión para listas vista en el ejercicio 14.

Además, agregaremos términos para representar listas por comprensión, con un selector y una guarda, de la siguiente manera: [M | x ← S, P], donde x es el nombre de una variable que puede aparecer libre en los términos M y P. La semántica es análoga a la de Haskell: para cada valor de la lista representada por el término S, se sustituye x en P y, de resultar verdadero, se agrega M con x sustituido al resultado. La regla de tipado para este nuevo término es la siguiente:

                                    Γ ∪ {x : τ} > M : σ   Γ > S : [τ]   Γ ∪ {x : τ} > P : Bool
                                    __________________________________________________________(T-Comp)
                                    Γ > [M|x ← S, P] : [σ]

i. Dar la modificación del algoritmo necesaria para soportar las listas por comprensión.

W([U|x ← V, T]) = S(Γ1') ∪ S(Γ2) ∪ S(Γ3') > S([M|x ← S, P]) : S([σ1])  

W(U) = Γ1 > M : σ1
W(V) = Γ2 > S : σ2
W(T) = Γ3 > P : σ3

τ_x1 | α si x : α ∈ Γ1
     | s variable fresca si no

τ_x2 | α si x : α ∈ Γ3
     | s variable fresca si no

S = MGU {τ_x1 ≐ τ_x2, σ2 ≐ [τ_x1], σ3 ≐ Bool} ∪ {σ1 ≐ σ2 | x : σ1 ∈ Γi, x : σ2 ∈ Γj, i, j ∈ {1', 2, 3'}}

Γ1' = Γ1 ⊖ {x}
Γ3' = Γ3 ⊖ {x}

ii. Aplicar el algoritmo extendido para tipar la siguiente expresión (sin renombrar ninguna variable):


                                                  [λy.succ(x) | x ← x True, y x] => {x : Bool → [Nat], y : Nat → Bool} > [λy.succ(x) | x ← x True, y x] : [t5 → Nat] 
                                                              |
                                                              | S = MGU {Nat ≐ t3, t6 ≐ [Nat], t7 ≐ Bool} = {} | {Nat/t3, [Nat]/t6, Bool/t7}
  ____________________________________________________________|____________________________________________________________
 |                                                            |                                                            |
λy.succ(x) => {x : Nat} > λy : t5.succ(x) : t5 → Nat         x True => {x : Bool → t6} > x True : t6                      y x => {y : t3 → t7, x : t3} > y x : t7
 |                                                            |                                                            |
 |                                                            | S = MGU {t1 ≐ Bool → t6} = {} | {Bool → t6/t1}             | S = MGU {t2 ≐ t3 → t7} = {} | {t3 → t7/t2}
 |                                          __________________|__________________                        __________________|__________________
succ(x) => {x : Nat} > succ(x) : Nat       |                                     |                      |                                     |
 |                                         x => {x : t1} > x : t1             True => ø > True : Bool   y => {y : t2} > y : t2                x => {x : t3} > x : t3
 | S = MGU {t4 ≐ Nat} = {} | {Nat/t4} 
 |
 x => {x : t4} > x : t4



17) 

En este ejercicio modificaremos el algoritmo de inferencia para incorporar la posibilidad de utilizar letrec en nuestro cálculo.

                                    M ::= . . .| letrec f = M in N
        
letrec permite por ejemplo representar el factorial de 10 de la siguiente manera:


                                    letrec f = (λ x : Nat. if isZero(x) then 1 else x × f (pred(x))) in f 10
    
Para ello se agrega la siguiente regla de tipado:

                                    Γ ∪ {f : π → τ} > M : π → τ   Γ ∪ {f : π → τ} > N : σ
                                    ______________________________________________________
                                    Γ > letrec f = M in N : σ

Suponiendo que se propone el siguiente pseudocódigo:
W(letrec f = M in N) = Γ > S (letrec f = M0 in N0): S σ donde:

W(M) = Γ1 > M0 : π → τ      (1)
W(N) = Γ2 > N0 : σ

S = MGU ({τ1 ≐ τ2 | f : τ1 ∈ Γ1 ∧ f : τ2 ∈ Γ2} ∪ COMPLETAR)
Γ = S Γ1 ∪ S Γ2

i. Explicar cuál es el error en los llamados recursivos. Dar un ejemplo que debería tipar y no lo hace debido a este error.

Se le pide de más al tipo de M0 en (1). Debería ser un tipo concreto pero no necesariamente tipo función.

                                     letrec f = x in y 
                                              |
                                              | Acá se produce el error dado que t1 no es de la forma π → τ. Sin embargo debería ser un término válido
         _____________________________________|_____________________________________
        |                                                                           |
        x => {x : t1} > x : t1                                                      y => {y : t2} > y : t2



ii. Explicar cuál es el error en el pseudocódigo con respecto la unificación de los contextos (pista: los nombres importan). Dar un ejemplo que debería tipar y no lo hace debido a este error.

Asume que f está en ambos términos y que llega a esta unificación con tipos asignados en ambos contextos.

                                letrec f = (λx.0) in f x
                                            |
                                            | Acá falla el MGU porque no hay información sobre f del lado izquierdo. Debería asignar una variable fresca y unificar con la derecha
       _____________________________________|_____________________________________
      |                                                                           |
    λx.0                                                                         f x => {f : t2 → t3, x : t2} > f x : t3
      |                                                         __________________|__________________
      0 => ø > 0 : Nat                                         |                                     |
                                                               f => {f : t1} > f : t1                x => {x : t2} > x : t2

iii. El contexto Γ ¿puede contener a f? ¿Es un comportamiento deseable? Mostrar un ejemplo donde esto trae conflictos (ayuda: usar letrec dentro de un término más grande).

No es deseable ya que f aparece ligada en este contexto. Debería poder usarse f por fuera de letrec de forma similar a lo que se hace con las variables ligadas en las lambdas.

                                                    (f 0) (letrec f = f True in f y)
                                                                 |
                                                                 | Acá se produce la colisión entre Nat y Bool al unificar los tipos de f
                                 ________________________________|______________________________
                                |                                                               |
                               f 0 => {f : Nat → t7} > f 0 : t7                               letrec f = (λx.f True) in f y => {f : Bool → t2, y : Bool} > letrec f = (λx.f True) in f y : t2
                                |                                                               |
                                | S = MGU {t6 ≐ Nat → t7} = {} | {Nat → t7/t6}                  | S = MGU {Bool → t2 ≐ t4 → t5, COMPLETAR} = {COMPLETAR} | {Bool/t4, t2/t5}
                   _____________|_____________                  ________________________________|________________________________
                  |                           |                |                                                                 |
                  f => {f : t6} > f : t6      0 => ø > 0 : Nat (λx.f True) => {f : Bool → t2} > λx : t3.f True : t3 → t2          f y => {f : t4 → t5, y : t4} > f y : t5
                                                               |                                                                 |
                                                               |                                                                 | S = MGU {t3 ≐ t4 → t5} = {} | {t4 → t5/t3}
                                                               |                                               __________________|__________________
                                                              f True => {f : Bool → t2} > f True : t2         |                                     |
                                                               |                                              f => {f : t3} > f : t3                y => {y : t4} > y : t4               
                                                               | S = MGU {t1 ≐ Bool → t2} = {} | {Bool → t2/t1}
                                             __________________|__________________
                                            |                                     |
                                            f => {f : t1} > f : t1               True => ø > True : Bool   


                   

iv. Reescribir el pseudocódigo para que funcione correctamente (corregir los errores y completar la definición de S).

W(letrec f = M in N) = S(Γ1') ∪ S(Γ2') > S(letrec f = M0 in N0): S(σ) donde:

W(M) = Γ1 > M0 : τ      
W(N) = Γ2 > N0 : σ

τ_f1 | α si f : α ∈ Γ1
     | s variable fresca si no

τ_f2 | α si f : α ∈ Γ2
     | s variable fresca si no

S = MGU {τ_f1 ≐ τ_f2, τ_f1 ≐ τ, τ ≐ s1 → s2} ∪ {σ1 ≐ σ2 | x : σ1 ∈ Γ1', x : σ2 ∈ Γ2'}

Γ1' = Γ1 ⊖ {f}
Γ2' = Γ2 ⊖ {f}

