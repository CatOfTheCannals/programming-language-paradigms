                                                                        INFERENCIA

1) Determinar qué expresiones son sintácticamente válidas y, para las que sean, indicar a qué gramática pertenecen.

PREGUNTA: los términos formados por variables de tipo son válidos en el cálculo lambda sin anotaciones o funcionan como un recurso para el algoritmo? Por ejemplo, λx: s1 → s2.if 0 then True else 0 succ(True)

______________________________________________________Válidas______________________________________________________
                
                Generadas por M                    Generadas por σ             Generadas por M'

                λx: Bool.succ(x)                       s → σ                     λx.isZero(x)
                
                                                         s
                                                        
                                                    s → (Bool → t)





_____________________________________________________Inválidas_____________________________________________________
                
                                                    Erase(f y) => Erase es parte de las expresiones asociadas al algoritmo de inferencia pero no forma parte de las del
                                                                                                                                                               lenguaje
                                           Erase(λf : Bool → s.λy : Bool.f y)
        


2) Determinar el resultado de aplicar la sustitución S a las siguientes expresiones.


i. S = {t ← Nat}    S({x : t → Bool}) => x : Nat → Bool

ii. S = {t1 ← t2 → t3, t ← Bool}    S({x : t → Bool}) > S(λx: t1 → Bool.x): S(Nat → t2) => {x : Bool → Bool} > (λx: t2 → t3 → Bool.x) : Nat → t2



3) Determinar el resultado de aplicar el MGU ("most general unifier") sobre las ecuaciones planteadas a continuación.

En caso de tener éxito, mostrar la sustitución resultante. 


i. MGU {t1 → t2 ≐ Nat → Bool} =1=> {t1 ≐ Nat, t2 ≐ Bool} =4=> {t2 ≐ Bool} | {Nat/t1} =4=> {} | {Bool/t2} ◦ {Nat/t1}  

ii. MGU {t1 → t2 ≐ t3} =3=> {t3 ≐ t1 → t2} =4=> {} | {t1 → t2/t3}

iii. MGU {t1 → t2 ≐ t2} =6=> ERROR

iv. MGU {(t2 → t1) → Bool ≐ t2 → t3} =1=> {t2 → t1 ≐ t2, t1 ≐ t3} =6=> ERROR 

v. MGU {t2 → t1 → Bool ≐ t2 → t3} =1=> {t2 ≐ t2, t1 → Bool ≐ t3} =2=> {t1 → Bool ≐ t3} =3=> {t3 ≐ t1 → Bool} =4=> {} | {t1 → Bool/t3}
                                                     
                                                 PREGUNTA: van paréntesis o no en el reemplazo de t1 por t2 → t3? @paréntesis
vi. MGU {t1 → Bool ≐ Nat → Bool, t1 ≐ t2 → t3} =4=> {(t2 → t3) → Bool ≐ Nat → Bool} | {t2 → t3/t1} =1=> {t2 → t3 ≐ Nat, Bool ≐ Bool} | {t2 → t3/t1} =5=> ERROR

vii. MGU {t1 → Bool ≐ Nat → Bool, t2 ≐ t1 → t1} =4=> {t1 → Bool ≐ Nat → Bool} | {t1 → t1/t2} =1=> {t1 ≐ Nat, Bool ≐ Bool} | {t1 → t1/t2} =4=> {Bool ≐ Bool} | {Nat/t1} ◦ {t1 → t1/t2} =2=> {} | {Nat/t1} ◦ {t1 → t1/t2} PREGUNTA: es correcto dejarlo así o debería aplicar Nat/t1 sobre todo lo que ya tenía? 

                                                         PREGUNTA: misma duda de paréntesis pero con el reemplazo de t3 por t2 → t1 @paréntesis
                                                                   si pongo paréntesis, queda t1 ≐ t2 → t1 y t2 ≐ t4 => ERROR
                                                                   si no pongo, tengo t1 ≐ t2 y t2 ≐ t1 → t4 =4=> t1 ≐ t1 → t4 =6=> ERROR
viii. MGU {t1 → t2 ≐ t3 → t4, t3 ≐ t2 → t1} =4=> {t1 → t2 ≐ (t2 → t1) → t4} | {t2 → t1/t3} =1=> {t1 ≐ t2 → t1, t2 ≐ t4} | {t2 → t1/t3} =6=> ERROR



4) Unir con flechas los tipos que unifican entre sí (entre una fila y la otra). Para cada par unificable, exhibir el mgu ("most general unifier").

t → u                   Nat                     u → Bool                    a → b → c


t                       Nat → Bool              (Nat → u) → Bool            Nat → u → Bool



t → u       con Nat → Bool          => {Nat/t, Bool/u}
            con u → Bool            => PREGUNTA: no se puede porque no hay un orden particular de la aplicación? Por ejemplo, {u/t, Bool/u} => Se puede: RECORDAR CORRER EL ALGORITMO SOBRE LA UNIFICACIÓN
            con (Nat → u) → Bool    => Idem anterior pero con {Nat → u/t, Bool/u}
            con Nat → u → Bool      => Idem anterior 
            con a → b → c           => PREGUNTA: Cuál es el mgu: {a/t, b → c/u} o {a → b/t, c/u}?

u → Bool    con Nat → Bool          => {Nat/u}

a → b → c   con (Nat → u) → Bool    => PREGUNTA: para lograr unificarlos debería ser posible agregar paréntesis, solamente se agregan cuando se reemplaza una variable 
                                                 por un tipo función? @paréntesis
   
t           con Nat                 => {Nat/t}
            con Nat → Bool          => {Nat → Bool/t}
            con u → Bool            => {u → Bool/t}
            con (Nat → u) → Bool    => {(Nat → u) → Bool/t}
            con a → b → c           => {a → b → c/t}
            con Nat → u → Bool      => {Nat → u → Bool/t}



5) Decidir, utilizando el método del árbol, cuáles de las siguientes expresiones son tipables. Mostrar qué reglas y sustituciones se aplican en cada paso y justificar por qué no son tipables aquéllas que fallan.

i. λz. if z then 0 else succ(0)

                                                                    λz. if z then 0 else succ(0) =>  ø > λz : Bool. if z then 0 else succ(0) : Bool → Nat
                                                                                 |
                                                                        if z then 0 else succ(0) => {z : Bool} > if z then 0 else succ(0) : Nat 
                                                                                 |
                                                                                 |               
                                                                                 | S = MGU {Nat ≐ Nat, t1 ≐ Bool} = {Bool/t1}
                                                                                 |
                         ________________________________________________________|________________________________________________________
                        |                                                        |                                                        |
                        z => {z : t1} > z : t1                                  0 => ø > 0 : Nat                                       succ(0) => ø > succ(0) : Nat
                                                                                                                                          |
                                                                                                                                          0 => ø > 0 : Nat



ii. λy. succ((λx.x) y)

                                                                    λy. succ((λx.x) y) => ø > λy : Nat. succ((λx.x) y) : Nat → Nat
                                                                            |
                                                                        succ((λx.x) y) => {y : Nat} > succ((λx.x) y) : Nat 
                                                                            |
                                                                            | S = MGU {t1 ≐ Nat} = {Nat/t1}
                                                                            |
                                                                         (λx.x) y => {y : t1} > (λx.x) y : t1  
                                                                            |
                                                                            | S = MGU {t1 → t1 ≐ t3 → t4} = {t1 ≐ t3, t1 ≐ t4} = {t1/t3, t1/t4}
                                    ________________________________________|________________________________________
                                   |                                                                                 |
                                  λx.x => ø > λx : t1.x : t1 → t1                                                    y => {y : t3} > y : t3
                                   |
                                   x => {x : t1} > x : t1  



iii. λx. if isZero(x) then x else (if x then x else x)


                        λx. if isZero(x) then x else (if x then x else x)
                                              |
                            if isZero(x) then x else (if x then x else x)
                                              |
                                              | S = MGU {Nat ≐ Bool, t5 ≐ Bool} => ERROR
       _______________________________________|_______________________________________
      |                                       |                                       |
   isZero(x) => {x : Nat} > isZero(x) : Bool  x => {x : t5} > x : t5        (if x then x else x) => {x : Bool} > (if x then x else x) : Bool 
      |                                                                               |
      x {x : t4} > x : t4                                                             |  S = MGU {t1 ≐ Bool, t1 ≐ t2, t2 ≐ t3, t1 ≐ t3} = {Bool/t1, Bool/t2, Bool/t3}
                                                               _______________________|_______________________       
                                                              |                       |                       |
                                                              x => {x : t1} > x : t1  x => {x : t2} > x : t2  x => {x : t3} > x : t3



iv. λx.λy. if x then y else succ(0)

                λx.λy. if x then y else succ(0) => ø > λx : Bool.λy : Nat. if x then y else succ(0) : Bool → Nat → Nat  
                            |
                   λy. if x then y else succ(0) => {x : Bool} > λy : Nat. if x then y else succ(0) : Nat → Nat 
                            |
                       if x then y else succ(0) => {x : Bool, y : Nat} > if  then y else succ(0) : Nat
                            |
                            | S = MGU {t2 ≐ Bool, t1 ≐ Nat} = {Bool/t2, Nat/t1} 
 ___________________________|___________________________
|                           |                           |
x => {x : t2} > x : t2      y => {y : y1} > y : t1   succ(0) => ø > succ(0) : Nat
                                                        |
                                                        0 => ø > 0 : Nat


Quedan para el lector (?
_________________________________________________
v. if True then (λx. 0) 0 else (λx. 0) False     |
vi. (λf. if True then f 0 else f False) (λx. 0)  |
vii. λx.λy.λz. if z then y else succ(x)          |
_________________________________________________|


viii. fix (λx. pred(x))

Para el punto viii, asumir extentido el algoritmo de inferencia con W(fix) = ∅ > fix_a : (a → a) → a donde a es una variable fresca.

                        fix (λx. pred(x)) => ø > fix (λx. pred(x)) : Nat 
                                |
                                | S = MGU {Nat → Nat ≐ t2 → t2} = {Nat ≐ t2, Nat ≐ t2} = {Nat ≐ t2} = {Nat/t2}
                                |
                             λx. pred(x) => ø > λx : Nat. pred(x) : Nat → Nat
                                |
                              pred(x) => {x : Nat} > pred(x) : Nat 
                                |
                                | S = MGU {t1 ≐ Nat} = {Nat/t1}
                                |
                                x => {x : t1} > x : t1



6) 

i. λx. λy. λz. (z x) y z

    PREGUNTA: podrían no estar los paréntesis y conservar la semántica?

                                                                      λx. λy. λz. (z x) y z
                                                                                |
                                                                        λy. λz. (z x) y z
                                                                                |
                                                                           λz. (z x) y z
                                                                                |
                                                                            (z x) y z
                                                                                |                                                   @paréntesis
                                                                                | S = MGU {t6 ≐ t2 → t4 → t5, t5 ≐ t6 → t7} = {t5 ≐ (t2 → t4 → t5) → t7} | {t2 → t4 → t5/ t6} => ERROR 
                                            ____________________________________|____________________________________
                                           |                                                                         |
                                        (z x) y => {z : t2 → t4 → t5, x : t2} > (z x) y : t5                         z => {z : t6} > z : t6
                                           |
                                           | S = MGU {t3 ≐ t4 → t5} = {t4 → t5/t3}
                       ____________________|____________________
                      |                                         |
                     z x => {z : t2 → t3, x : t2} > z x : t3    y => {y : t4} > y : t4
                      |
                      | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/ t1}
  ____________________|____________________
 |                                         |
 z => {z : t1} > z : t1                    x => {x : t2} > x : t2


Para el lector parte 2.
_________________________
ii.                      |
...                      |
vii.                     |
_________________________|



7) Indicar tipos σ y τ apropiados de modo que los términos de la forma λy : σ.λx : τ.y^n(x) resulten tipables para todo n natural. El par (σ, τ) debe ser el mismo para todos los términos. Observar si tienen todos el mismo tipo. Notación: M^0(N) = N, M^(n+1)(N) = M(M^n(N)). Sugerencia: empezar haciendo inferencia para n = 2 (es decir, calcular W(λy.λx.y(yx))) y generalizar el resultado.


                                                                            λy.λx.y(yx) => ø > λy : t3 → t3.λx : t3.y(yx) : (t3 → t3) → t3 → t3 
                                                                                |
                                                                             λx.y(yx) => {y : t3 → t3} > λx : t3.y(yx) : t3 → t3 
                                                                                |
                                                                              y(yx) => {y : t3 → t3, x : t3} > y(yx) : t3
                                                                                |
                                                                                | S = MGU {t4 ≐ t2 → t3, t4 ≐ t3 → t5} = {t2 → t3 ≐ t3 → t5} | {t2 → t3/t4} = {t2 → t3/t4, t3/t2, t3/t5}
                                                                   _____________|_____________
                                                                  |                           |
                                                                  y => {y : t4} > y : t4     yx => {y : t2 → t3, x : t2} > y x : t3
                                                                                              |
                                                                                              | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/t1}
                                                                                 _____________|_____________
                                                                                |                           |
                                                                                y => {y : t1} > y : t1      x => {x : t2} > x :t2



Dado que y toma elementos de su imagen como argumento (ya que se puede hacer y(yx)), entonces los tipos del dominio y la imágen deben coincidir (t3 → t3). Por otro lado, como x es pasado como argumento de y, debe tener el tipo que acepta y (t3). Finalmente, debido a que la lambda es una aplicación anidada de y, el tipo de salida es el de la imagen de y (t3).

En general, tomando (σ, τ) = (t3 → t3, t3) se consigue lo que se quiere.

Todos los términos tienen el mismo tipo ya que los tipos de los argumentos no cambian aunque lo haga el subtérmino de la lambda. Es decir, continúa recibiendo una función de tipo t3 → t3, una variable de tipo t3 y devuelve algo de tipo t3.

PREGUNTA: es necesaria la demostración por inducción?

Sean M : t3 → t3 y N : t3. Supongo que vale que M^k(N) : t3, con k >= 2, entonces, si R = M^k(N), por E-App vale M R : t3. Es decir, M(M^k(N)) : t3 => M^(k+1)(N) : t3.  



8) 

PREGUNTA: qué pasa si me quedan variables de tipo al terminar la aplicación del algoritmo? reemplazo por tipos genéricos? NO! DEVUEVLO ASÍ 

                                                                                λy.(x y) (λz.x2) => {x : t2 → (t5 → t4) → t7, x2 : t4} > λy : t2.(x y) (λz.x2) : t2 → t7
                                                                                        |
                                                                                   (x y) (λz.x2) => {x : t2 → (t5 → t4) → t7, y : t2, x2 : t4} > (x y) (λz.x2) : t7 
                                                                                        |
                                                                                        | S = MGU {t3 ≐ (t5 → t4) → t7} = {(t5 → t4) → t7/t3}
                                            ____________________________________________|____________________________________________
                                           |                                                                                         |
                                          x y => {x : t2 → t3, y : t2} > x y : t3                                                  λz.x2 => {x2 : t4} > λz : t5.x2 : t5 → t4
                                           |                                                                                         |   
                                           | S = MGU {t1 ≐ t2 → t3} = {t2 → t3/t1}                                                  x2 => {x2 : t4} > x2 : t4
                           ________________|________________                                                                         
                          |                                 |                                                                        
                          x => {x : t1} > x : t1            y => {y : t2} > y : t2





{x : σ → (t5 → ρ) → τ, x2 : ρ} > λy : σ.(x y) (λz.x2) : σ → τ







