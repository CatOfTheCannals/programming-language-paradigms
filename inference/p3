                                                                        INFERENCIA

1) Determinar qué expresiones son sintácticamente válidas y, para las que sean, indicar a qué gramática pertenecen.

PREGUNTA: los términos formados por variables de tipo son válidos en el cálculo lambda sin anotaciones o funcionan como un recurso para el algoritmo? Por ejemplo, λx: s1 → s2.if 0 then True else 0 succ(True)

______________________________________________________Válidas______________________________________________________
                
                Generadas por M                    Generadas por σ             Generadas por M'

                λx: Bool.succ(x)                       s → σ                     λx.isZero(x)
                
                                                         s
                                                        
                                                    s → (Bool → t)





_____________________________________________________Inválidas_____________________________________________________
                
                                                    Erase(f y) => Erase es parte de las expresiones asociadas al algoritmo de inferencia pero no forma parte de las del
                                                                                                                                                               lenguaje
                                           Erase(λf : Bool → s.λy : Bool.f y)
        


2) Determinar el resultado de aplicar la sustitución S a las siguientes expresiones.


i. S = {t ← Nat}    S({x : t → Bool}) => x : Nat → Bool

ii. S = {t1 ← t2 → t3, t ← Bool}    S({x : t → Bool}) > S(λx: t1 → Bool.x): S(Nat → t2) => {x : Bool → Bool} > (λx: t2 → t3 → Bool.x) : Nat → t2



3) Determinar el resultado de aplicar el MGU ("most general unifier") sobre las ecuaciones planteadas a continuación.

En caso de tener éxito, mostrar la sustitución resultante. 


i. MGU {t1 → t2 ≐ Nat → Bool} =1=> {t1 ≐ Nat, t2 ≐ Bool} =4=> {t2 ≐ Bool} | {Nat/t1} =4=> {} | {Bool/t2} ◦ {Nat/t1}  

ii. MGU {t1 → t2 ≐ t3} =3=> {t3 ≐ t1 → t2} =4=> {} | {t1 → t2/t3}

iii. MGU {t1 → t2 ≐ t2} =6=> ERROR

iv. MGU {(t2 → t1) → Bool ≐ t2 → t3} =1=> {t2 → t1 ≐ t2, t1 ≐ t3} =6=> ERROR 

v. MGU {t2 → t1 → Bool ≐ t2 → t3} =1=> {t2 ≐ t2, t1 → Bool ≐ t3} =2=> {t1 → Bool ≐ t3} =3=> {t3 ≐ t1 → Bool} =4=> {} | {t1 → Bool/t3}
                                                     
                                                 PREGUNTA: van paréntesis o no en el reemplazo de t1 por t2 → t3? @paréntesis
vi. MGU {t1 → Bool ≐ Nat → Bool, t1 ≐ t2 → t3} =4=> {(t2 → t3) → Bool ≐ Nat → Bool} | {t2 → t3/t1} =1=> {t2 → t3 ≐ Nat, Bool ≐ Bool} | {t2 → t3/t1} =5=> ERROR

vii. MGU {t1 → Bool ≐ Nat → Bool, t2 ≐ t1 → t1} =4=> {t1 → Bool ≐ Nat → Bool} | {t1 → t1/t2} =1=> {t1 ≐ Nat, Bool ≐ Bool} | {t1 → t1/t2} =4=> {Bool ≐ Bool} | {Nat/t1} ◦ {t1 → t1/t2} =2=> {} | {Nat/t1} ◦ {t1 → t1/t2} PREGUNTA: es correcto dejarlo así o debería aplicar Nat/t1 sobre todo lo que ya tenía? 

                                                         PREGUNTA: misma duda de paréntesis pero con el reemplazo de t3 por t2 → t1 @paréntesis
                                                                   si pongo paréntesis, queda t1 ≐ t2 → t1 y t2 ≐ t4 => ERROR
                                                                   si no pongo, tengo t1 ≐ t2 y t2 ≐ t1 → t4 =4=> t1 ≐ t1 → t4 =6=> ERROR
viii. MGU {t1 → t2 ≐ t3 → t4, t3 ≐ t2 → t1} =4=> {t1 → t2 ≐ (t2 → t1) → t4} | {t2 → t1/t3} =1=> {t1 ≐ t2 → t1, t2 ≐ t4} | {t2 → t1/t3} =6=> ERROR



4) Unir con flechas los tipos que unifican entre sí (entre una fila y la otra). Para cada par unificable, exhibir el mgu ("most general unifier").

t → u                   Nat                     u → Bool                    a → b → c


t                       Nat → Bool              (Nat → u) → Bool            Nat → u → Bool



t → u       con Nat → Bool          => {Nat/t, Bool/u}
            con u → Bool            => PREGUNTA: no se puede porque no hay un orden particular de la aplicación? Por ejemplo, {u/t, Bool/u}
            con (Nat → u) → Bool    => Idem anterior pero con {Nat → u/t, Bool/u}
            con Nat → u → Bool      => Idem anterior 
            con a → b → c           => PREGUNTA: Cuál es el mgu: {a/t, b → c/u} o {a → b/t, c/u}?

u → Bool    con Nat → Bool          => {Nat/u}

a → b → c   con (Nat → u) → Bool    => PREGUNTA: para lograr unificarlos debería ser posible agregar paréntesis, solamente se agregan cuando se reemplaza una variable 
                                                 por un tipo función? @paréntesis
   
t           con Nat                 => {Nat/t}
            con Nat → Bool          => {Nat → Bool/t}
            con u → Bool            => {u → Bool/t}
            con (Nat → u) → Bool    => {(Nat → u) → Bool/t}
            con a → b → c           => {a → b → c/t}
            con Nat → u → Bool      => {Nat → u → Bool/t}



5) Decidir, utilizando el método del árbol, cuáles de las siguientes expresiones son tipables. Mostrar qué reglas y sustituciones se aplican en cada paso y justificar por qué no son tipables aquéllas que fallan.

                                                                    λz. if z then 0 else succ(0)
                         ________________________________________________________|________________________________________________________
                        |                                                        |                                                        |
                        z => {z : t1} > z : t1                                  0 => ø > 0 : Nat                                       succ(0) => ø > succ(0) : Nat
                                                                                                                                          |
                                                                                                                                          0 => ø > 0 : Nat

























  
