                                                                        INFERENCIA

1) Determinar qué expresiones son sintácticamente válidas y, para las que sean, indicar a qué gramática pertenecen.

PREGUNTA: los términos formados por variables de tipo son válidos en el cálculo lambda sin anotaciones o funcionan como un recurso para el algoritmo? Por ejemplo, λx: s1 → s2.if 0 then True else 0 succ(True)

______________________________________________________Válidas______________________________________________________
                
                Generadas por M                    Generadas por σ             Generadas por M'

                λx: Bool.succ(x)                       s → σ                     λx.isZero(x)
                
                                                         s
                                                        
                                                    s → (Bool → t)





_____________________________________________________Inválidas_____________________________________________________
                
                                                    Erase(f y) => Erase es parte de las expresiones asociadas al algoritmo de inferencia pero no forma parte de las del
                                                                                                                                                               lenguaje
                                           Erase(λf : Bool → s.λy : Bool.f y)
        


2) Determinar el resultado de aplicar la sustitución S a las siguientes expresiones.


i. S = {t ← Nat}    S({x : t → Bool}) => x : Nat → Bool

ii. S = {t1 ← t2 → t3, t ← Bool}    S({x : t → Bool}) > S(λx: t1 → Bool.x): S(Nat → t2) => {x : Bool → Bool} > (λx: t2 → t3 → Bool.x) : Nat → t2



3) Determinar el resultado de aplicar el MGU ("most general unifier") sobre las ecuaciones planteadas a continuación.

En caso de tener éxito, mostrar la sustitución resultante. 


i. MGU {t1 → t2 ≐ Nat → Bool} =1=> {t1 ≐ Nat, t2 ≐ Bool} =4=> {t2 ≐ Bool} | {Nat/t1} =4=> {} | {Bool/t2} ◦ {Nat/t1}  

ii. MGU {t1 → t2 ≐ t3} =3=> {t3 ≐ t1 → t2} =4=> {} | {t1 → t2/t3}

iii. MGU {t1 → t2 ≐ t2} =6=> ERROR

iv. MGU {(t2 → t1) → Bool ≐ t2 → t3} =1=> {t2 → t1 ≐ t2, t1 ≐ t3} =6=> ERROR 

v. MGU {t2 → t1 → Bool ≐ t2 → t3} =1=> {t2 ≐ t2, t1 → Bool ≐ t3} =2=> {t1 → Bool ≐ t3} =3=> {t3 ≐ t1 → Bool} =4=> {} | {t1 → Bool/t3}
                                                     
                                                 PREGUNTA: van paréntesis o no en el reemplazo de t1 por t2 → t3? @paréntesis
vi. MGU {t1 → Bool ≐ Nat → Bool, t1 ≐ t2 → t3} =4=> {(t2 → t3) → Bool ≐ Nat → Bool} | {t2 → t3/t1} =1=> {t2 → t3 ≐ Nat, Bool ≐ Bool} | {t2 → t3/t1} =5=> ERROR

vii. MGU {t1 → Bool ≐ Nat → Bool, t2 ≐ t1 → t1} =4=> {t1 → Bool ≐ Nat → Bool} | {t1 → t1/t2} =1=> {t1 ≐ Nat, Bool ≐ Bool} | {t1 → t1/t2} =4=> {Bool ≐ Bool} | {Nat/t1} ◦ {t1 → t1/t2} =2=> {} | {Nat/t1} ◦ {t1 → t1/t2} PREGUNTA: es correcto dejarlo así o debería aplicar Nat/t1 sobre todo lo que ya tenía? 

                                                         PREGUNTA: misma duda de paréntesis pero con el reemplazo de t3 por t2 → t1 @paréntesis
                                                                   si pongo paréntesis, queda t1 ≐ t2 → t1 y t2 ≐ t4 => ERROR
                                                                   si no pongo, tengo t1 ≐ t2 y t2 ≐ t1 → t4 =4=> t1 ≐ t1 → t4 =6=> ERROR
viii. MGU {t1 → t2 ≐ t3 → t4, t3 ≐ t2 → t1} =4=> {t1 → t2 ≐ (t2 → t1) → t4} | {t2 → t1/t3} =1=> {t1 ≐ t2 → t1, t2 ≐ t4} | {t2 → t1/t3} =6=> ERROR



4) Unir con flechas los tipos que unifican entre sí (entre una fila y la otra). Para cada par unificable, exhibir el mgu ("most general unifier").

t → u                   Nat                     u → Bool                    a → b → c


t                       Nat → Bool              (Nat → u) → Bool            Nat → u → Bool



t → u       con Nat → Bool          => {Nat/t, Bool/u}
            con u → Bool            => PREGUNTA: no se puede porque no hay un orden particular de la aplicación? Por ejemplo, {u/t, Bool/u}
            con (Nat → u) → Bool    => Idem anterior pero con {Nat → u/t, Bool/u}
            con Nat → u → Bool      => Idem anterior 
            con a → b → c           => PREGUNTA: Cuál es el mgu: {a/t, b → c/u} o {a → b/t, c/u}?

u → Bool    con Nat → Bool          => {Nat/u}

a → b → c   con (Nat → u) → Bool    => PREGUNTA: para lograr unificarlos debería ser posible agregar paréntesis, solamente se agregan cuando se reemplaza una variable 
                                                 por un tipo función? @paréntesis
   
t           con Nat                 => {Nat/t}
            con Nat → Bool          => {Nat → Bool/t}
            con u → Bool            => {u → Bool/t}
            con (Nat → u) → Bool    => {(Nat → u) → Bool/t}
            con a → b → c           => {a → b → c/t}
            con Nat → u → Bool      => {Nat → u → Bool/t}



5) Decidir, utilizando el método del árbol, cuáles de las siguientes expresiones son tipables. Mostrar qué reglas y sustituciones se aplican en cada paso y justificar por qué no son tipables aquéllas que fallan.

i. λz. if z then 0 else succ(0)

                                                                    λz. if z then 0 else succ(0) =>  ø > λz : Bool. if z then 0 else succ(0) : Bool → Nat
                                                                                 |
                                                                        if z then 0 else succ(0) => {z : Bool} > if z then 0 else succ(0) : Nat 
                                                                                 |
                                                                                 |               
                                                                                 | S = MGU {Nat ≐ Nat, t1 ≐ Bool} = {Bool/t1}
                                                                                 |
                         ________________________________________________________|________________________________________________________
                        |                                                        |                                                        |
                        z => {z : t1} > z : t1                                  0 => ø > 0 : Nat                                       succ(0) => ø > succ(0) : Nat
                                                                                                                                          |
                                                                                                                                          0 => ø > 0 : Nat



ii. λy. succ((λx.x) y)

                                                                    λy. succ((λx.x) y) => ø > λy : Nat. succ((λx.x) y) : Nat → Nat
                                                                            |
                                                                        succ((λx.x) y) => {y : Nat} > succ((λx.x) y) : Nat 
                                                                            |
                                                                            | S = MGU {t1 ≐ Nat} = {Nat/t1}
                                                                            |
                                                                         (λx.x) y => {y : t1} > (λx.x) y : t1  
                                                                            |
                                                                            | S = MGU {t1 → t1 ≐ t3 → t4} = {t1 ≐ t3, t1 ≐ t4} = {t1/t3, t1/t4}
                                    ________________________________________|________________________________________
                                   |                                                                                 |
                                  λx.x => ø > λx : t1.x : t1 → t1                                                    y => {y : t3} > y : t3
                                   |
                                   x => {x : t1} > x : t1  



iii. λx. if isZero(x) then x else (if x then x else x)


                        λx. if isZero(x) then x else (if x then x else x)
                                              |
                            if isZero(x) then x else (if x then x else x)
                                              |
                                              | S = MGU {Nat ≐ Bool, t5 ≐ Bool} => ERROR
       _______________________________________|_______________________________________
      |                                       |                                       |
   isZero(x) => {x : Nat} > isZero(x) : Bool  x => {x : t5} > x : t5        (if x then x else x) => {x : Bool} > (if x then x else x) : Bool 
      |                                                                               |
      x {x : t4} > x : t4                                                             |  S = MGU {t1 ≐ Bool, t1 ≐ t2, t2 ≐ t3, t1 ≐ t3} = {Bool/t1, Bool/t2, Bool/t3}
                                                               _______________________|_______________________       
                                                              |                       |                       |
                                                              x => {x : t1} > x : t1  x => {x : t2} > x : t2  x => {x : t3} > x : t3



iv. λx.λy. if x then y else succ(0)

                λx.λy. if x then y else succ(0) => ø > λx : Bool.λy : Nat. if x then y else succ(0) : Bool → Nat → Nat  
                            |
                   λy. if x then y else succ(0) => {x : Bool} > λy : Nat. if x then y else succ(0) : Nat → Nat 
                            |
                       if x then y else succ(0) => {x : Bool, y : Nat} > if  then y else succ(0) : Nat
                            |
                            | S = MGU {t2 ≐ Bool, t1 ≐ Nat} = {Bool/t2, Nat/t1} 
 ___________________________|___________________________
|                           |                           |
x => {x : t2} > x : t2      y => {y : y1} > y : t1   succ(0) => ø > succ(0) : Nat
                                                        |
                                                        0 => ø > 0 : Nat


Quedan para el lector (?

v. if True then (λx. 0) 0 else (λx. 0) False
vi. (λf. if True then f 0 else f False) (λx. 0)
vii. λx.λy.λz. if z then y else succ(x) 



viii. fix (λx. pred(x))

Para el punto viii, asumir extentido el algoritmo de inferencia con W(fix) = ∅ > fix_a : (a → a) → a donde a es una variable fresca.

                        fix (λx. pred(x)) => ø > fix (λx. pred(x)) : Nat 
                                |
                                | S = MGU {Nat → Nat ≐ t2 → t2} = {Nat ≐ t2, Nat ≐ t2} = {Nat ≐ t2} = {Nat/t2}
                                |
                             λx. pred(x) => ø > λx : Nat. pred(x) : Nat → Nat
                                |
                              pred(x) => {x : Nat} > pred(x) : Nat 
                                |
                                | S = MGU {t1 ≐ Nat} = {Nat/t1}
                                |
                                x => {x : t1} > x : t1










  
